<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: combinator | Higher Order うさぎ小屋]]></title>
  <link href="http://solorab.github.io/blog/categories/combinator/atom.xml" rel="self"/>
  <link href="http://solorab.github.io/"/>
  <updated>2014-04-13T02:48:20+09:00</updated>
  <id>http://solorab.github.io/</id>
  <author>
    <name><![CDATA[そろうさぎ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[lazy kでhello world書いた]]></title>
    <link href="http://solorab.github.io/blog/2014/04/09/hello-world-in-lazy-k/"/>
    <updated>2014-04-09T00:19:29+09:00</updated>
    <id>http://solorab.github.io/blog/2014/04/09/hello-world-in-lazy-k</id>
    <content type="html"><![CDATA[<ul>
  <li>“hello world”</li>
  <li>9000byteぐらい</li>
  <li>できるだけ自力で書いた</li>
  <li>CPPを使用 (<code>gcc -E</code>)</li>
  <li><a href="/blog/2014/04/05/lambda-calculus-for-great-good/">ラムダ計算について調べた</a>のを有効活用した</li>
  <li>楽しい</li>
</ul>

<!-- more -->

<h2 id="lazy-k-is-">Lazy K is 何</h2>
<ul>
  <li><a href="http://legacy.e.tir.jp/wiliki?%cb%dd%cc%f5%3a%a5%d7%a5%ed%a5%b0%a5%e9%a5%df%a5%f3%a5%b0%b8%c0%b8%ecLazy_K">翻訳:プログラミング言語Lazy_K</a></li>
  <li><a href="http://blog.livedoor.jp/dankogai/archives/51524324.html">404 Blog Not Found:Math - 言語はどこまで小さくなれるか - (unlambda|iota|jot) のすすめ</a>
    <ul>
      <li>ここのpatchあてて-fpermissiveしたらcompile通った</li>
    </ul>
  </li>
  <li>すごそう</li>
  <li>かっこいい</li>
</ul>

<h2 id="section">入出力</h2>
<ul>
  <li>プログラムに引数として標準入力が与えられ、返り値が標準出力に出る</li>
  <li>つまり <code>getContents &gt;&gt;= (pure . main) &gt;&gt;= putStr</code></li>
  <li>ただし文字列はチャーチ数のスコットエンコーディングのリスト
    <ul>
      <li><a href="http://d.hatena.ne.jp/syamino/20120524/p1">ラムダ計算で代数的データ型を表現する方法 - @syamino はてなダイアリー</a></li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="ignoreinput">ignore_input</h2>

<p><code>c
    #define ignore_input k
</code></p>

<ul>
  <li>code頭に置いて、入力を無視する</li>
  <li><code>k PROGRAM INPUT -&gt; PROGRAM</code></li>
</ul>

<h2 id="section-1">簡単な関数</h2>
<p><code>c
    #define id (skk)
    #define true k
    #define false (ki)
    #define zero false
    #define one id
</code></p>

<p>何とか書ける</p>

<h2 id="car-cdr--head-tail">car cdr / head tail</h2>
<ul>
  <li><code>car list = list true</code></li>
  <li><code>cdr list = list false</code></li>
</ul>

<p>しかし</p>

<p><code>
    \ x y . y x
</code></p>

<p>が書けない</p>

<p>とりあえず文字列を持ってきて<code>true</code>/<code>false</code>を試してみる</p>

<p><a href="https://ja.wikipedia.org/wiki/Hello_world%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E4%B8%80%E8%A6%A7#Lazy_K">Hello worldプログラムの一覧 # Lazy_K - Wikipedia</a></p>

<p><code>c
    #define helloworld ``s``si`k</code>s<code>sss</code><code>s</code><code>s</code>ks<code>ssi</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k` \
       </code>ss<code>s</code>ss<code>ki</code><code>ss</code><code>ss`ss</code>ss<code>ki</code><code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``si``ss``ss`ki</code> \
        ss<code>s</code><code>sss</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k</code><code>s</code><code>si</code><code>ss</code><code>ss</code>ki<code>ss`s``sss``ss`ki` \
        `s`ksk`k``s``si`k</code>ss<code>s</code>sss<code>ss</code><code>ss</code>ss<code>ss`ki</code>s<code>ksk</code>k<code>s</code>si<code>k</code><code>ss` \
        `ss</code>s<code>sss</code>s<code>sss</code>ss<code>ki</code><code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``ss</code>ssi<code>ss`ki</code>ss<code>ki</code> \
        <code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``si``ss``s``sss``ss`ki``ss</code>ss<code>ssi</code>ss<code>ki</code><code>s</code>ksk<code> \
        k</code><code>s</code><code>si</code>k<code>ss``s``sss``ss</code>ss<code>ss</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k</code><code>ss</code><code>ss</code><code>ss \
        </code><code>ss</code><code>s</code><code>sss</code><code>ss</code><code>ss`ss</code>ss<code>ki</code><code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``si``ss``ss`ki</code>ss \
        <code>s</code><code>sss</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k</code><code>s</code><code>ss</code>ki<code>ss</code><code>ss</code>ss<code>ss`ki</code>s<code>ksk</code>k<code>\
        s</code>si<code>k</code><code>ss</code><code>ss</code>ss<code>ss`ki</code>s<code>ksk</code>k<code>k</code><code>sii</code><code>sii</code><code>s</code><code>s</code>kski
```</p>

<p><code>c
    ignore_input (helloworld false)
    ##=&gt; ello, world
</code></p>

<p>動く</p>

<h2 id="t">T[]変換</h2>
<ul>
  <li>救世主現る</li>
  <li><a href="http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E8%AB%96%E7%90%86#S-K\_basis.E3.81.AE.E5.AE.8C.E5.85.A8.E6.80.A7">コンビネータ論理 # T[] 変換について - Wikipedia</a></li>
  <li>わりと簡単な<code>lambda式 -&gt; skiコンビネータ</code>の変換</li>
  <li>eta簡約もすると短くなる <code>(s (k X) i) -&gt; X</code></li>
</ul>

<h2 id="x-y-y-x">\ x y. y x</h2>
<p>wikipediaの例と同じだけど、自分でも変換する</p>

<p><code>c
    #define rev (s (k (s i)) k)
</code></p>

<h2 id="car--cdr">car / cdr</h2>
<p><code>\ x y. y x</code> ができたので作れるように</p>

<p><code>c
    #define car (rev true)
    #define cdr (rev false)
</code></p>

<p><code>c
    ignore_input (cdr helloworld)
    ##=&gt; ello, world
</code></p>

<h2 id="succ">succ</h2>
<ul>
  <li><code>\ n f x. f (n f x)</code> も変換</li>
  <li>結構頑張る</li>
</ul>

<p><code>c
    #define succ (s (k (s (s (k s) k))) (s (s (k s) k) (k i)))
</code></p>

<h2 id="cons">cons</h2>
<ul>
  <li><code>succ</code>だけあっても使えないので<code>cons</code></li>
  <li>lazy-kはスコットエンコーディング</li>
  <li><code>\ x y z . z x y</code></li>
</ul>

<p><code>c
    #define cons (s (s (k s) (s (k k) (s (k s) (s (k (s i)) (s (k k) i))))) (k (s (k k) i)))
</code></p>

<p><code>c
    #define cons (s (s (k s) (s (k k) (s (k s) (s (k (s i)) k)))) (k k))
    ##=&gt; Iello, world
</code></p>

<h2 id="section-2">演算</h2>
<p><code>
    plus = \ m n. m succ n
    mult = \ m n f. m (n f)
    pow = \ m n n (mult m) one # 不要
</code></p>

<p><code>c
    #define plus (s (s (k s) (s (k k) (s i (k succ)))) (k i))
    #define mult (s (s (k s) (s (k k) (s (k s) k))) (k i))
    #define pow (s (s (k s) (s (k (s i)) (s (k k) mult))) (k (k one)))
</code></p>

<ul>
  <li>手作業で丁寧に変換</li>
</ul>

<h2 id="hello-world">hello world</h2>

<h3 id="section-3">出力すべき数を確認する</h3>

<p>``` sh
    $ ghc -e ‘print $ map ord “hello world”’
    [104,101,108,108,111,32,119,111,114,108,100]</p>

<pre><code>$ ghc -e 'print $ map (($ "") . showIntAtBase 2 intToDigit . ord) "hello world"'
["1101000","1100101","1101100","1101100","1101111","100000","1110111","1101111","1110010","1101100","1100100"] ```
</code></pre>

<h3 id="section-4">数字を定義</h3>
<p><code>c
    #define two (s (s (k s) k) i) # 無駄な変換
    #define double (mult two)
    #define four (double two)
    #define eight (double four)
    #define sixteen (double eight)
    #define thirtytwo (double sixteen)
    #define sixtyfour (double thirtytwo)
    #define eof (pow four four)
</code></p>

<ul>
  <li>lazy-kは<code>256</code>をもって<code>eof</code>とする</li>
  <li>2進数万歳</li>
  <li>2は変換しておいた</li>
</ul>

<h3 id="section-5">完成</h3>

<p><code>scheme
    ignore_input
    (cons (plus sixtyfour (plus thirtytwo eight)) # h
    (cons (plus sixtyfour (plus thirtytwo (plus four one))) # e
    (cons (plus sixtyfour (plus thirtytwo (plus eight four))) # l
    (cons (plus sixtyfour (plus thirtytwo (plus eight four))) # l
    (cons (plus sixtyfour (plus thirtytwo (plus eight (plus four (plus two one))))) # o
    (cons thirtytwo # ' '
    (cons (plus sixtyfour (plus thirtytwo (plus sixteen (plus four (plus two one))))) # w
    (cons (plus sixtyfour (plus thirtytwo (plus eight (plus four (plus two one))))) # o
    (cons (plus sixtyfour (plus thirtytwo (plus sixteen two))) # r
    (cons (plus sixtyfour (plus thirtytwo (plus eight four))) # l
    (cons (plus sixtyfour (plus thirtytwo four)) # e
    (cons eof k))))))))))))
</code></p>

<p><code>sh
    $ gcc -E a.lazy.cpp &gt; a.lazy &amp;&amp; echo hoge | ./lazy a.lazy
    hello world
</code></p>

<hr />

<dl>
  <dt>2014/04/11</dt>
  <dd><code>two</code>の定義が抜けてたので修正</dd>
</dl>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[すごいラムダ計算楽しく学ぼう]]></title>
    <link href="http://solorab.github.io/blog/2014/04/05/lambda-calculus-for-great-good/"/>
    <updated>2014-04-05T20:24:26+09:00</updated>
    <id>http://solorab.github.io/blog/2014/04/05/lambda-calculus-for-great-good</id>
    <content type="html"><![CDATA[<ul>
  <li>以前挑んだ時は惨敗したが、今回は程よく分かるので楽しい</li>
  <li>haskellにとってのlambda計算は、cにとってのbrainf*ckみたいなものっぽい</li>
  <li>教養の域を出なさそうだが楽しいので許す</li>
  <li>楽しい(自己暗示)</li>
</ul>

<!-- more -->
<!-- c は色付けのため -->

<h2 id="lambda">lambda計算とは</h2>
<ul>
  <li>無名関数のみで計算</li>
  <li><code>λ x y. y x</code>
    <ul>
      <li>haskellだと<code>\ x y -&gt; y x</code></li>
      <li>schemeだと<code>(lambda (x) (lambda (y) (y x)))</code></li>
      <li>pythonだと<code>lambda x : lambda y : y(x)</code></li>
    </ul>
  </li>
  <li># <code>λ</code>って打つの面倒なので<code>\</code>で代替</li>
</ul>

<h2 id="section">変換</h2>
<dl>
  <dt>alpha変換</dt>
  <dd>変数の名前は変えれるよ <code>(\ a -&gt; a) -&gt; (\ b -&gt; b)</code>
beta簡約</dd>
  <dd>関数適用のこと <code>(\ x -&gt; f x) y -&gt; f y</code>
eta変換</dd>
  <dd>const除去 <code>(\ _. a) b = (const a) b -&gt; a</code></dd>
</dl>

<h2 id="section-1">関数</h2>
<ul>
  <li>可読性のためhaskellから輸入しておく</li>
  <li>combinator理論</li>
</ul>

<p><code>c
    const x y = x
    id x = x
</code></p>

<h2 id="church">church数</h2>
<p><code>
    0 = \ s o.      o
    1 = \ s o.    s o
    2 = \ s o. s (s o)
    succ n   = \ s o.   s (n s o)
    plus m n = \ s o. m s (n s o)
    mult m n = \ s. m (n s)
</code></p>

<ul>
  <li><code>(x -&gt; x) -&gt; x -&gt; x</code>な関数を数とみなす</li>
  <li><code>numberToInt a = a (+1) 0 :: (forall x. (x -&gt; x) -&gt; x -&gt; x) -&gt; Int</code></li>
  <li><code>Int -&gt; (a -&gt; a) -&gt; a</code>な関数はhayooでググったら<code>nest</code>って名前ついてたけど、<code>3 ~ nest 3</code>と思えば自然</li>
</ul>

<p>演算の定義別version</p>

<p><code>c
    plus m n = m succ n
    mult m n = m (plus n) 0
</code></p>

<h3 id="pred">pred</h3>
<ul>
  <li><code>- 1</code></li>
  <li>&lt;-&gt; <code>succ</code></li>
  <li>最大の山場だった</li>
  <li>山場過ぎて<a href="/blog/2014/04/05/church-number-and-pred-function/">別記事</a>に切り出した</li>
</ul>

<h3 id="section-2">減算</h3>
<p><code>
    sub m n = n pred m
</code></p>

<ul>
  <li><code>plus m n = m succ n</code>なことを考えると当然だった</li>
  <li>引数と定義部の順序の違いには注意すべきか</li>
</ul>

<h2 id="section-3">真偽値</h2>
<p><code>
    true  t f = t
    false t f = f
    if p t f = p t f
</code></p>

<p><code>c
    if true  t f = t
    if false t f = f
</code></p>

<ul>
  <li><code>a -&gt; a -&gt; a</code>を真偽値とみなす</li>
  <li>分岐構造,jump命令が値に組み込まれている</li>
  <li><code>if</code>は構文糖</li>
</ul>

<h3 id="section-4">論理演算</h3>
<p><code>
    not p   = \ t f. p f t
    and p q = \ t f. p (q t f) f
    or  p q = \ t f. p t (q t f)
    xor p q = \ t f. p (q f t) (q t f)
</code></p>

<ul>
  <li>所詮if文なので楽勝</li>
</ul>

<p><code>c
    not p   = p false true
    and p q = p q false
    or  p q = p true q
    xor p q = p (not q) q
</code></p>

<ul>
  <li>point-freeの綺麗な定義</li>
</ul>

<h2 id="section-5">比較</h2>

<h3 id="section-6">0判定</h3>
<p><code>
    iszero n = n (const false) true
</code></p>

<p><code>c
    iszero 2
    \ t f. iszero 2 t f
    \ t f. 2 (const false) true t f
    \ t f. (const false) ((const false) true) t f
    \ t f. false t f
    \ t f. f
    false
</code></p>

<p><code>c
    iszero 0
    \ t f. iszero 0 t f
    \ t f. 0 (cons false) true t f
    \ t f. true t f
    \ t f. t
    true
</code></p>

<p>よく見たら定義からして<code>0 = flip const = false</code>だった</p>

<h3 id="section-7">大小比較</h3>
<p><code>
    gte m n = iszero (sub m n)
</code></p>

<ul>
  <li>sub,predは負数にはならず0となるので</li>
</ul>

<h3 id="section-8">等値判定</h3>
<p><code>
    equal m n = and (gte m n) (gte n m)
</code></p>

<ul>
  <li>十分高級なので問題ないね</li>
</ul>

<h2 id="loop">loop</h2>
<p><code>
    Y = \ f. (\ x. f (x x)) (\ x. f (x x)))
</code></p>

<ul>
  <li>Y-combinatorと言うらしい</li>
  <li>意外に簡単だった</li>
  <li>というか既に慣れ親しんでた</li>
</ul>

<p><code>c
    Y f x
    (\y.f(y y)) (\y.f(y y)) x
    f ((\y.f(y y)) (\y.f(y y))) x
    f (f ((\y.f(y y)) (\y.f(y y)))) x
</code></p>

<p>やたら同じものが出てくるので<code>y = (\ x. f (x x))</code>とおいてみる</p>

<p><code>c
    Y f x
    y y x
    f (y y) x
    f (f (y y)) x
</code></p>

<p><code>Y</code>を<code>Y</code>で定義できそうなので元の式を弄くる</p>

<p><code>c
    Y f = y y
        = f (y y)
        = f (Y f)
</code></p>

<ul>
  <li>haskellのfixと全く同じだったようだ</li>
</ul>

<h3 id="section-9">階乗</h3>
<p>lambda計算のような何か</p>

<p><code>c
    fact = Y (\ recur n. (iszero n) 1 (mult n (recur (pred n))))
</code></p>

<p>有効なhaskell-code</p>

<p><code>c haskell
    fact = fix $ \ recur n -&gt; if n == 0 then 1 else n * recur (n - 1)
</code></p>

<p>完全に一致</p>

<h2 id="pair">pair</h2>
<p><code>
    pair l r = \ f. f l r
    fst p = p (\ l r. l)
    snd p = p (\ l r. r)
</code></p>

<p><code>c
    swap p = p (\ l r. r l)
    uncurry f = \ p. p (\ l r. f l r)
    uncurry f p = p f
</code></p>

<p>問題ない</p>

<h2 id="list">list</h2>
<p><code>
    cons x y = \ c n. c x (y c n)
    nil      = \ c n. n
</code></p>

<p><code>c
    foldr f a0 xs
        = xs f a0
        = cons a (cons b (cons c (... (cons y (cons z nil))))) f a0
        = f    a (f    b (f    c (... (f    y (f    z  a0))))) f a0
</code></p>

<p><code>c
    map f = foldr (\ x. cons (f x)) nil
    length = foldr (const succ) 0
</code></p>

<ul>
  <li>church encoding と scott encoding の違いだとかはよく分からない</li>
  <li>手計算なのでそろそろ不安</li>
  <li>to be continued…</li>
</ul>

<h2 id="section-10">参考</h2>
<p>主に <a href="http://uid0130.blogspot.jp/2013/05/x.html">uid0130-blog: ラムダ計算の使い方</a></p>

<p>他にも:</p>

<ul>
  <li><a href="http://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%A0%E3%83%80%E8%A8%88%E7%AE%97">ラムダ計算 - Wikipedia</a></li>
  <li><a href="http://www.slideshare.net/bleistift/f-28987517">F#の基礎(嘘)</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
