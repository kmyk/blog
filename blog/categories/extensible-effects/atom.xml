<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: extensible-effects | Higher Order うさぎ小屋]]></title>
  <link href="http://solorab.github.io/blog/categories/extensible-effects/atom.xml" rel="self"/>
  <link href="http://solorab.github.io/"/>
  <updated>2014-05-10T17:22:52+09:00</updated>
  <id>http://solorab.github.io/</id>
  <author>
    <name><![CDATA[そろうさぎ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[extensible-effects上にoperational monad作ってみた]]></title>
    <link href="http://solorab.github.io/blog/2014/03/13/operational-monad-on-extensible-effects/"/>
    <updated>2014-03-13T22:29:54+09:00</updated>
    <id>http://solorab.github.io/blog/2014/03/13/operational-monad-on-extensible-effects</id>
    <content type="html"><![CDATA[<p>extensible-effects上にoperational作った<br />
正確には、型パズル解いて遊んでいたらoperationalができていた</p>

<p>利点:</p>

<ul>
  <li>extensible-effectsとoperationalが合わさって最強に見える</li>
</ul>

<p>欠点:</p>

<ul>
  <li>Typeable1の宣言が必要
    <ul>
      <li>GADTs使うとderivingできないので面倒 (THで解決?)</li>
    </ul>
  </li>
</ul>

<!-- more -->

<h2 id="code">code</h2>

<p>``` haskell
    {-# LANGUAGE ExistentialQuantification #-}
    {-# LANGUAGE FlexibleContexts #-}
    {-# LANGUAGE MultiParamTypeClasses #-}
    {-# LANGUAGE Rank2Types #-}
    {-# LANGUAGE ScopedTypeVariables #-}
    {-# LANGUAGE TypeOperators #-}
    module Control.Eff.Operational (Program, singleton, runProgram) where</p>

<pre><code>import Control.Eff (Eff, Member, (:&gt;), VE(Val, E), inj, send, admin, handleRelay)
import Data.Typeable (Typeable1, typeOf1, mkTyCon3, mkTyConApp)

data Program m v = forall a. Program (m a) (a -&gt; v)

instance Functor (Program m) where
    fmap f (Program m k) = Program m (f . k)

instance Typeable1 m =&gt; Typeable1 (Program m) where
    typeOf1 _ = mkTyConApp (mkTyCon3 "" "Control.Eff.Operational" "Program")
                           [typeOf1 (undefined :: m ())]

singleton :: (Typeable1 m, Member (Program m) r) =&gt; m a -&gt; Eff r a
singleton m = send (inj . Program m)

runProgram :: Typeable1 f =&gt; (forall x. f x -&gt; Eff r x) -&gt; Eff (Program f :&gt; r) a -&gt; Eff r a
runProgram advent = loop . admin where
    loop (Val x) = return x
    loop (E u) = handleRelay u loop
        (\ (Program m k) -&gt; loop . k =&lt;&lt; advent m) ```
</code></pre>

<h2 id="section">比較</h2>
<p><code>haskell
    runProgram :: Typeable1 f          =&gt; (forall x. f x -&gt; Eff r x) -&gt; Eff (Program f :&gt; r) a -&gt; Eff r a
    interpret  :: (Functor m, Monad m) =&gt; (forall x. instr x -&gt; m x) -&gt;      Program instr   a -&gt;     m a
</code></p>

<p>当然似ている</p>

<h2 id="example">example</h2>

<p>``` haskell
    data Jail a where
        Print :: String -&gt; Jail ()
        Scan :: Jail String</p>

<pre><code>instance Typeable1 Jail where
    typeOf1 _ = mkTyConApp (mkTyCon3 "test" "Main" "Jail") []

prog :: Member (Program Jail) r =&gt; Eff r ()
prog = do
    singleton $ Print "getting input..."
    str &lt;- singleton Scan
    singleton $ Print "ok"
    singleton $ Print ("the input is " ++ str)

adventIO :: (Member (Lift IO) r, SetMember Lift (Lift IO) r) =&gt; Jail a -&gt; Eff r a
adventIO (Print a) = lift $ putStrLn a
adventIO Scan = lift getLine

main :: IO ()
main = runLift $ runProgram adventIO prog ```
</code></pre>

<p>もちろんrunProgramの第一引数は自由に差し替えられる</p>

<p><code>haskell
    adventPure :: (Member (Writer String) r, Member (State [String]) r) =&gt; Jail a -&gt; Eff r a
    adventPure (Print a) = tell a
    adventPure Scan = do
        x &lt;- (fromMaybe [] . headMay) &lt;$&gt; get
        modify (tailSafe :: [String] -&gt; [String])
        return x
</code></p>

<p>型注釈はextensible-effectsの問題 newtypeすれば消えます</p>

<h2 id="section-1">おまけ</h2>
<p>advent部分の制約にoperationalを使うと、つまりoperationalの実装をoperationalで与えるといろいろ楽しい</p>

<p><code>haskell
    advent :: (Member (Program t) r) =&gt; t a -&gt; Eff r a
    runProgram advent :: (Member (Program t) r) =&gt; Eff (Program t :&gt; r) a -&gt; Eff r a
</code></p>

<p><code>haskell
    advent :: (Member (Program t) r, Member (Program u) r) =&gt; s a -&gt; Eff r a
    runProgram advent :: (Member (Program t) r, Member (Program u) r) =&gt; Eff (Program s :&gt; r) a -&gt; Eff r a
</code></p>

<p><code>haskell
    advent  :: (Member (Program u) r) =&gt; s a -&gt; Eff r a
    advent' :: (Member (Program u) r) =&gt; t a -&gt; Eff r a
    runProgram advent' . runProgram advent :: (Member (Program u) r) =&gt; Eff (Program s :&gt; Program t :&gt; r) a -&gt; Eff r a
</code></p>

<h2 id="section-2">関連</h2>
<ul>
  <li><a href="http://notogawa.hatenablog.com/entry/2014/02/22/004828">IOアクションひとつひとつを利用許諾し・テスト可能にする - ぼくのぬまち 出張版</a></li>
  <li><a href="http://fumieval.hatenablog.com/entry/2013/05/09/223604">Freeモナドを超えた！？operationalモナドを使ってみよう - モナドとわたしとコモナド</a></li>
</ul>

<hr />

<dl>
  <dt>2014/04/11</dt>
  <dd>冗長だった部分を削減</dd>
</dl>
]]></content>
  </entry>
  
</feed>
