<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: haskell | 高機能うさぎ小屋]]></title>
  <link href="http://solorab.github.io/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://solorab.github.io/"/>
  <updated>2014-03-14T01:51:19+09:00</updated>
  <id>http://solorab.github.io/</id>
  <author>
    <name><![CDATA[そろうさぎ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[extensible-effects上にoperational monad作ってみた]]></title>
    <link href="http://solorab.github.io/blog/2014/03/13/operational-monad-on-extensible-effects/"/>
    <updated>2014-03-13T22:29:54+09:00</updated>
    <id>http://solorab.github.io/blog/2014/03/13/operational-monad-on-extensible-effects</id>
    <content type="html"><![CDATA[<p>extensible-effects上にoperational作った<br />
正確には、型パズル解いて遊んでいたらoperationalができていた</p>

<p>利点:</p>

<ul>
  <li>extensible-effectsとoperationalが合わさって最強に見える</li>
</ul>

<p>欠点:</p>

<ul>
  <li>Typeable1の宣言が必要
    <ul>
      <li>GADTs使うとderivingできないので面倒 (THで解決?)</li>
    </ul>
  </li>
</ul>

<!-- more -->

<h2 id="code">code</h2>

<p>``` haskell
    {-# LANGUAGE ExistentialQuantification #-}
    {-# LANGUAGE FlexibleContexts #-}
    {-# LANGUAGE MultiParamTypeClasses #-}
    {-# LANGUAGE Rank2Types #-}
    {-# LANGUAGE ScopedTypeVariables #-}
    {-# LANGUAGE TypeOperators #-}
    module Control.Eff.Operational (Program, singleton, runProgram) where</p>

<pre><code>import Control.Eff (Eff, Member, (:&gt;), VE(Val, E), inj, send, admin, handleRelay)
import Data.Typeable (Typeable1, typeOf1, mkTyCon3, mkTyConApp)

data Program m v = forall a. Program (m a) (a -&gt; v)

instance Functor (Program m) where
    fmap f (Program m k) = Program m (f . k)

instance Typeable1 m =&gt; Typeable1 (Program m) where
    typeOf1 _ = mkTyConApp (mkTyCon3 "" "Control.Eff.Operational" "Program")
                           [typeOf1 (undefined :: m ())]

singleton :: (Typeable1 m, Member (Program m) r) =&gt; m a -&gt; Eff r a
singleton m = send (inj . Program m)

runProgram :: Typeable1 f =&gt; (forall x. f x -&gt; Eff r x) -&gt; Eff (Program f :&gt; r) a -&gt; Eff r a
runProgram advent = loop . admin where
    loop (Val x) = return x
    loop (E u) = handleRelay u loop
        (\ (Program m k) -&gt; loop . k =&lt;&lt; advent m) ```
</code></pre>

<h2 id="section">比較</h2>
<p><code>haskell
    runProgram :: Typeable1 f          =&gt; (forall x. f x -&gt; Eff r x) -&gt; Eff (Program f :&gt; r) a -&gt; Eff r a
    interpret  :: (Functor m, Monad m) =&gt; (forall x. instr x -&gt; m x) -&gt;      Program instr   a -&gt;     m a
</code></p>

<p>当然似ている</p>

<h2 id="example">example</h2>

<p>``` haskell
    data Jail a where
        Print :: String -&gt; Jail ()
        Scan :: Jail String</p>

<pre><code>instance Typeable1 Jail where
    typeOf1 _ = mkTyConApp (mkTyCon3 "test" "Main" "Jail") []

prog :: Member (Program Jail) r =&gt; Eff r ()
prog = do
    singleton $ Print "getting input..."
    str &lt;- singleton Scan
    singleton $ Print "ok"
    singleton $ Print ("the input is " ++ str)

adventIO :: (Member (Lift IO) r, SetMember Lift (Lift IO) r) =&gt; Jail a -&gt; Eff r a
adventIO (Print a) = lift $ putStrLn a
adventIO Scan = lift getLine

main :: IO ()
main = runLift $ runProgram adventIO prog ```
</code></pre>

<p>もちろんrunProgramの第一引数は自由に差し替えられる</p>

<p><code>haskell
    adventPure :: (Member (Writer String) r, Member (State [String]) r) =&gt; Jail a -&gt; Eff r a
    adventPure (Print a) = tell a
    adventPure Scan = do
        x &lt;- (fromMaybe [] . headMay) &lt;$&gt; get
        modify (tailSafe :: [String] -&gt; [String])
        return x
</code></p>

<p>型注釈はextensible-effectsの問題 newtypeすれば消えます</p>

<h2 id="section-1">おまけ</h2>
<p>以下、自分でもあまりよく分かっていない</p>

<h3 id="section-2">構造</h3>
<p>なにか面白げな構造ができていた 圏っぽいなにか<br />
何の役に立つかは検討もつかない</p>

<p><code>~&gt;</code>の左辺domain部分は必ず<code>Program *</code>だが、右辺codomain部分は必ずしも<code>Program *</code>でなくてもよい (ただし不可逆)</p>

<h4 id="map-id--program-t--program-t">map (id) : <code>Program t ~&gt; Program t</code></h4>
<p>内側へ埋め込む効果がある</p>

<p><code>haskell
    advent :: (Member (Program t) r) =&gt; t a -&gt; Eff r a
    runProgram advent :: (Member (Program t) r) =&gt; Eff (Program t :&gt; r) a -&gt; Eff r a
</code></p>

<p>先程の例を使うと</p>

<p><code>haskell
    adventEndo :: (Member (Program Jail) r) =&gt; Jail a -&gt; Eff r a
    adventEndo (Print a) = singleton . Print $ "    " ++ a
    adventEndo Scan = return "banned"
</code></p>

<h4 id="split--program-s--program-t-program-u">split : <code>Program s ~&gt; (Program t, Program u)</code></h4>
<p>実装を部分的に注入するのに使えるか</p>

<p><code>haskell
    advent :: (Member (Program t) r, Member (Program u) r) =&gt; s a -&gt; Eff r a
    runProgram advent :: (Member (Program t) r, Member (Program u) r) =&gt; Eff (Program s :&gt; r) a -&gt; Eff r a
</code></p>

<h4 id="join--program-s-program-t--program-u">join : <code>(Program s, Program t) ~&gt; Program u</code></h4>
<p>contexts制約部が大きくてよく分からなくなった時に、まとめるのに便利か</p>

<p><code>haskell
    advent  :: (Member (Program u) r) =&gt; s a -&gt; Eff r a
    advent' :: (Member (Program u) r) =&gt; t a -&gt; Eff r a
    runProgram advent' . runProgram advent :: (Member (Program u) r) =&gt; Eff (Program s :&gt; Program t :&gt; r) a -&gt; Eff r a
    runProgram advent . runProgram advent' :: (Member (Program u) r) =&gt; Eff (Program t :&gt; Program s :&gt; r) a -&gt; Eff r a
</code></p>

<h2 id="section-3">関連</h2>
<ul>
  <li><a href="http://notogawa.hatenablog.com/entry/2014/02/22/004828">IOアクションひとつひとつを利用許諾し・テスト可能にする - ぼくのぬまち 出張版</a></li>
  <li><a href="http://fumieval.hatenablog.com/entry/2013/05/09/223604">Freeモナドを超えた！？operationalモナドを使ってみよう - モナドとわたしとコモナド</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[parsecで非決定的パース]]></title>
    <link href="http://solorab.github.io/blog/2014/01/25/non-deterministic-parsing-with-parsec/"/>
    <updated>2014-01-25T18:28:27+09:00</updated>
    <id>http://solorab.github.io/blog/2014/01/25/non-deterministic-parsing-with-parsec</id>
    <content type="html"><![CDATA[<p>ざっくりparseして、出力を<code>filter</code>や<code>head</code>で加工したかった</p>

<p><code>haskell
    fork :: [ParsecT s u [] a] -&gt; ParsecT s u [] a
    fork = join . lift
</code></p>

<p>※ list-monadで非決定的計算できるのは、parsecに限った話ではない</p>

<!-- more -->

<p><code>ParsecT</code>をlist-monadと合成するだけなので、上のように定義する<br />
型注釈なしなら<code>join . lift :: (Monad (t m), Monad m, MonadTrans t) =&gt; m (t m a) -&gt; t m a</code></p>

<p>非決定的の厳密な定義を知らないが、chooseとfail<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>が使えるので非決定的と呼んでいいはず<br />
ただし<code>fail = fork []</code>であって、<code>Prelude.fail</code>(<code>Text.Parsec.parserFail</code>)ではない</p>

<h2 id="section">例</h2>

<p>``` haskell
    p = try p’ &lt;|&gt; many1 anyChar where
        p’ = do
            x &lt;- manyTill anyChar $ char ‘+’
            fork
                [ return x
                , (x ++) &lt;$&gt; p
                ]</p>

<pre><code>&gt;&gt;&gt; runParserT p () "input" "a+b+c" where
[Right "a",Right "ab",Right "abc"] ```
</code></pre>

<p>``` haskell
    q = try q’ &lt;|&gt; fork [] where
        q’ = do
            x &lt;- p
            fork
                [ return [x]
                , (x :) &lt;$&gt; q
                ]</p>

<pre><code>&gt;&gt;&gt; runParserT p () "input" "a+b+c" where
[Right ["a"],Right ["a","b"],Right ["a","b","c"],Right ["a","bc"],Right ["ab"],Right ["ab","c"],Right ["abc"]] ```
</code></pre>

<p><code>ここではきものをぬいでください</code>のような文をparseするとき便利なんじゃないでしょうか</p>

<h2 id="section-1">参考</h2>

<ul>
  <li><a href="http://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/nondeterminism.html">On Lisp — 非決定性</a></li>
  <li><a href="http://hooki.blog23.fc2.com/blog-entry-74.html">雑草ブログ Listモナドで非決定的計算をしよう</a></li>
</ul>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>On Lispの説明による<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Int]をparsecでパースする]]></title>
    <link href="http://solorab.github.io/blog/2014/01/25/parse-list-of-ints-with-parsec/"/>
    <updated>2014-01-25T17:50:35+09:00</updated>
    <id>http://solorab.github.io/blog/2014/01/25/parse-list-of-ints-with-parsec</id>
    <content type="html"><![CDATA[<p>``` haskell
    »&gt; parse (many even’) “numbers” [0,0,2,4,9999]
    Right [0,0,2,4]</p>

<pre><code>&gt;&gt;&gt; parse (many (zero &lt;|&gt; odd') &gt;&gt; eof) "numbers" [0,1,1,3,5,8]
Left "numbers" (line 1, column 6):
unexpected 8
expecting zero, odd or end of input ```
</code></pre>

<p><code>[Int]</code>だとおふざけだが、複雑な何かだと便利かもしれない<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<!-- more -->

<p><code>Monad m =&gt; Stream [tok] m tok</code>とあるので、<code>list</code>に包めば何でもparse可能に見える<br />
しかし<code>Stream s m Char =&gt;</code>制約の代わりに<code>(Stream s m tok, Eq tok) =&gt;</code>なものが<del>見当たらない</del><br />
標準の<code>satisfy</code>さえ<code>:: Stream s m Char =&gt; (Char -&gt; Bool) -&gt; ParsecT s u m Char</code>と、<code>Char</code>しか受け入れてくれない<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup><br />
<del>仕方がないので</del><ins>仕方なくなかった(<a href="#ins">追記</a>)</ins><code>satisfy</code>を再定義する</p>

<p>``` haskell
    updatePos :: SourcePos -&gt; Column -&gt; SourcePos
    updatePos p n = setSourceColumn p (sourceColumn p + n)</p>

<pre><code>satisfy' :: (Stream s m t, Show t) =&gt; (t -&gt; Bool) -&gt; ParsecT s u m t
satisfy' f = tokenPrim show
    (\ pos _ _ -&gt; updatePos pos 1)
    (\ c -&gt; if f c then Just c else Nothing) ```
</code></pre>

<p><code>Text.Parsec.Char</code>のほぼ全ての関数<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>は<code>satisfy</code>経由で定義されているので、<br />
<code>Text.Parsec.Int</code>を作ることが可能になる</p>

<p><code>haskell
    zero :: (Num a, Eq a, Stream s m a, Show a) =&gt; ParsecT s u m a
    zero = satisfy' (== 0) &lt;?&gt; "zero"
    even', odd' :: (Integral a, Stream s m a, Show a) =&gt; ParsecT s u m a
    even' = satisfy' even &lt;?&gt; "even"
    odd' = satisfy' odd &lt;?&gt; "odd"
</code></p>

<h2 id="section">参考</h2>
<ul>
  <li><a href="http://hackage.haskell.org/package/parsec">Hackage: parsec: Monadic parser combinators</a></li>
  <li><a href="http://qiita.com/hiratara/items/a451b04fb19bfcc7ff08">Haskell - Parsecのソースちら見(3) - Qiita</a></li>
</ul>

<h2 id="ins">追記</h2>
<p>定義されてた</p>

<p><a href="http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Combinator.html#v:anyToken">Text.Parsec.Combinator.anyToken</a><br />
<code>anyToken :: (Stream s m t, Show t) =&gt; ParsecT s u m t</code></p>

<p>なので</p>

<p><code>haskell
    satisfy' f = try $ lookAhead (anyToken &gt;&gt;= (\ x -&gt; if f x then return x else unexpected $ show x))
</code>
としても良い</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>便利でないかもしれない<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>parser-libraryなので当然<a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p><code>Text.Parsec.Char.string</code>以外の全て<a href="#fnref:3" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[free monadとはmonadそのものである]]></title>
    <link href="http://solorab.github.io/blog/2013/12/29/free-monad-is-monad-itself/"/>
    <updated>2013-12-29T17:22:11+09:00</updated>
    <id>http://solorab.github.io/blog/2013/12/29/free-monad-is-monad-itself</id>
    <content type="html"><![CDATA[<p>以前少し挑戦して敗れたが、ふと思い出してリベンジした</p>

<p>結論としては<code>free monad</code>とはmonadをdataとして表現したものであると</p>

<p><code>haskell
    data Free f a = Pure a | Free (f (Free f a))
    instance Functor f =&gt; Monad (Free f) where
        return = Pure
        Pure a &gt;&gt;= k = k a
        Free fm &gt;&gt;= k = Free (fmap (&gt;&gt;=k) fm)
</code></p>

<!-- more -->

<h2 id="section">型のイメージ</h2>
<p>型レベルで、<code>ffffffffa</code>や<code>ffa</code>のような構造を畳み込む<br />
つまり<code>Free f a</code>は<code>fffffffa</code>と読み替えられる</p>

<p>たとえば</p>

<ul>
  <li><code>Free [] a</code> ~ <code>[[[[[a]]]]]</code></li>
  <li><code>Free Maybe a</code> ~ <code>Maybe (Maybe (Maybe a))</code></li>
</ul>

<h2 id="section-1">値と型</h2>
<p><code>haskell
    Free [Free [Free [Pure ()]]] :: Free [] ()
    Free [Pure 3, Pure 2, Free [Pure 1, Free []], Pure 0] :: Num a =&gt; Free [] a
    Free [] :: Free [] a
    Pure () :: Free f ()
    Free [Pure $ Free [Pure ()]] :: Free [] (Free [] ())
</code>
よく分からない</p>

<h2 id="join">手を動かす: join</h2>
<p><code>&gt;&gt;=</code>や<code>bind</code>と呼ばれる<code>Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</code>は<br />
<code>Control.Monad.join</code>こと<code>Monad m =&gt; m (m a) -&gt; m a</code>で定義できる<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>ので<br />
理解のため<code>join</code>を定義してみる</p>

<p><code>haskell
    join' :: Functor f =&gt; Free f (Free f a) -&gt; Free f a
    join' (Pure a) = a
    join' (Free fFreefa) = Free (fmap join' fFreefa)
</code></p>

<h3 id="maybe">実際に: Maybe</h3>
<p><code>haskell
    &gt;&gt;&gt; let x = Free$Just (Free$Just (Pure (Free$Just (Pure Nothing))))
    &gt;&gt;&gt; :t x
    x :: Free Maybe (Free Maybe (Maybe a))
    &gt;&gt;&gt; join x
    Free (Just (Free (Just (Free (Just (Pure Nothing))))))
</code>
手で追う</p>

<p><code>haskell
    join          (Free$Just (Free$Just (Pure (Free$Just (Pure Nothing)))))
    Free (fmap   join $ Just (Free$Just (Pure (Free$Just (Pure Nothing)))))
    Free (Just $ join        (Free$Just (Pure (Free$Just (Pure Nothing)))))
    Free$Just          (join (Free$Just (Pure (Free$Just (Pure Nothing)))))
    Free$Just          (Free$Just (join (Pure (Free$Just (Pure Nothing)))))
    Free$Just          (Free$Just             (Free$Just (Pure Nothing)))
                   Free$Just (Free$Just       (Free$Just (Pure Nothing)))
</code></p>

<ol>
  <li>初期状態</li>
  <li><code>join</code>の展開</li>
  <li><code>fmap</code>の展開: <code>fmap f (Just a) = Just (f a)</code></li>
  <li>見やすくしただけ: <code>join</code>と<code>Free$Just</code>が入れ替わったのが分かる</li>
  <li>同様にする</li>
  <li><code>Pure</code>は<code>join</code>と対消滅する</li>
  <li>見やすくしただけ: 外側のPureを道連れにjoinが消え、外側と内側のFreeの境目を潰しているのが分かる</li>
</ol>

<h3 id="list">もう少し複雑な例: List</h3>
<p><code>haskell
    &gt;&gt;&gt; let x = Free[ Free[ Free[], Pure( Free[] ) ], Pure( Free[ Pure() ] ) ]
    &gt;&gt;&gt; :t x
    x :: Free [] (Free [] ())
    &gt;&gt;&gt; join x
    Free [Free [Free [],Free []],Free [Pure ()]]
</code></p>

<p><code>haskell
    join$Free[      Free[      Free[],      Pure( Free[] ) ],      Pure( Free[ Pure() ] ) ]
         Free[ join$Free[      Free[],      Pure( Free[] ) ], join$Pure( Free[ Pure() ] ) ]
         Free[      Free[ join$Free[], join$Pure( Free[] ) ],            Free[ Pure() ]   ]
         Free[      Free[      Free[],            Free[]   ],            Free[ Pure() ]   ]
</code></p>

<h3 id="section-2">解釈</h3>
<p><code>join</code>の型が<code>Free f (Free f a) -&gt; Free f a</code>で、<code>Free f a</code>は<code>fffffffa</code>などと読み替えられることから、<br />
<code>join</code>とは<code>ffff(ffffa) -&gt; ffffffffa</code>的ななにかである<br />
それともつじつまの合う結果である<br />
なんとなく雰囲気はつかめた</p>

<h3 id="bind">bindへ</h3>
<p>そして</p>

<p><code>haskell
    bind :: (Functor m, Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
    bind x f = join $ fmap f x
</code>
である<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<p><code>haskell
    &gt;&gt;&gt; Free[ Pure 7, Pure 2 ] &gt;&gt;= (\ x -&gt; Free[ Pure (show x), Pure (show (x ^ x)) ])
    Free [Free [Pure "7",Pure "823543"],Free [Pure "2",Pure "4"]]
</code>
右辺のPureの位置に左辺が埋め込まれている</p>

<h2 id="section-3">自由</h2>
<p>弄っていたらいつの間にか気がついた<br />
<code>Free</code>の<code>free</code>とはおそらくfree monoidやfree magmaの<code>free</code>であろう<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup><br />
つまり、公理の等式以外に元の間の関係式をもたない、という意味<br />
この場合公理とはモナド則</p>

<p>つまりGADTsで定義して見やすくすると</p>

<p><code>haskell
    class Functor m =&gt; Monad m where
        unit :: a -&gt; m a
        join :: m (m a) -&gt; m a
    data FreeMonad f a where
        Unit :: a -&gt; FreeMonad f a
        Join :: f (FreeMonad f a) -&gt; FreeMonad f a
</code>
とある程度綺麗に対応している</p>

<h2 id="section-4">結論</h2>
<p><code>Free</code>とはmonadそのものであり、monadをdataとして表現したものである<br />
lispに似ているなと感じる</p>

<h2 id="section-5">予防線と残った疑問</h2>
<p><code>free monad</code>には別の定義も存在して</p>

<p><code>haskell
    -- join / f無し
    data FreeMonad a where
        Unit :: a -&gt; FreeMonad a
        Join :: FreeMonad (FreeMonad a) -&gt; FreeMonad a
</code></p>

<p><code>haskell
    -- bind / f無し
    data FreeMonad a where
        Return :: a -&gt; FreeMonad a
        Bind :: FreeMonad x -&gt; (x -&gt; FreeMonad a) -&gt; FreeMonad a
</code></p>

<p><code>haskell
    -- bind / f有り(BindのFreeMonad消去)
    data FreeMonad f a where
        Return :: a -&gt; FreeMonad f a
        Bind :: f x -&gt; (x -&gt; FreeMonad f a) -&gt; FreeMonad f a
</code>
と思いつく範囲だけで3つ<br />
しかもこの3つは<code>f Functor</code>制約なしでmonadになる</p>

<p><code>haskell
    -- bind / f無し
    instance Monad FreeMonad where
        return = Return
        (&gt;&gt;=) = Bind
</code></p>

<p><code>haskell
    -- bind / f有り(BindのFreeMonad消去)
    instance Monad (FreeMonad f) where
        return = Return
        (&gt;&gt;=) (Return a) a2fb = a2fb a
        (&gt;&gt;=) (Bind fx x2fa) a2fb = Bind fx ((&gt;&gt;= a2fb) . x2fa)
</code></p>

<p>一方<code>Free</code>で使われている定義は</p>

<p><code>haskell
    -- join / f有り(JoinのFreeMonad消去)
    instance Functor f =&gt; Functor (FreeMonad f) where
        fmap a2b (Unit a) = Unit $ a2b a
        fmap a2b (Join ffa) = Join $ fmap (fmap a2b) ffa
    join' :: Functor f =&gt; FreeMonad f (FreeMonad f a) -&gt; FreeMonad f a
    join' (Unit a) = a
    join' (Join ffa) = Join $ fmap join' ffa
    instance Functor f =&gt; Monad (FreeMonad f) where
        return = Unit
        (&gt;&gt;=) fa a2fb = join' $ fmap a2fb fa
</code>
と要Functor制約<br />
<code>Join</code>の<code>f (FreeMonad f a)</code>を展開するのにどうしても必要なようだ<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p>

<p>そしてそもそも<code>f</code>が入るとはどういうことなのかいまいち分からない<br />
もしかしたら<code>Free</code>はfree monadでなく類似の別な概念のfreeかもしれない<br />
圏論に精通していないので分からない<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p>

<h3 id="operational">operational</h3>
<p>さらに強いと聞くoperational monadはこのbind型のfree monadなのではと考えた</p>

<p><code>haskell
    type Program t = Free (Coyoneda t)
</code>
らしく、</p>

<p><code>haskell
    data Coyoneda t x where
        Coyoneda :: t r -&gt; (r -&gt; a) -&gt; Coyoneda t a
    instance Functor (Coyoneda t) where
        fmap f (Coyoneda t g) = Coyoneda t (f . g)
</code>
とcoyonedaは制約なしでfunctorを作るので、ただのdataからmonadになるのだそうだ</p>

<p>coyonedaのmoduleも<code>Data.Functor.Coyoneda</code>にあるので、free functor的ななにかだと思い、<br />
free functorとfree monadを合成してもfree monadだろうという発想から少し頑張った<br />
しかし型パズルが解けずinterpretが定義できないので、全く違うのかもしれないし、haskell力足りていないだけかもしれない</p>

<h2 id="section-6">参考</h2>
<ul>
  <li><a href="http://d.hatena.ne.jp/fumiexcel/20121111/1352614885">そろそろFreeモナドに関して一言いっとくか - fumievalの日記</a></li>
  <li><a href="http://d.hatena.ne.jp/its_out_of_tune/20121111/1352632815">Freeモナドって何なのさっ！？ - capriccioso String Creating(Object something){ return My.Expression(something); }</a></li>
</ul>

<h3 id="operational-1">operational</h3>
<ul>
  <li><a href="http://d.hatena.ne.jp/its_out_of_tune/20130601/1370109743">YonedaとCoYoneda、そしてFunctor - capriccioso String Creating(Object something){ return My.Expression(something); }</a></li>
  <li><a href="http://fumieval.hatenablog.com/entry/2013/11/11/154146">Operationalモナドをゲームに応用した話 - モナドとわたしとコモナド</a></li>
  <li><a href="http://myuon-myon.hatenablog.com/entry/2013/06/09/135407">Yoneda lemmaとOperational Monad - Just $ A sandbox</a></li>
  <li><a href="http://togetter.com/li/526588">Operational Monad - Togetterまとめ</a></li>
</ul>

<h2 id="packages">packages</h2>
<ul>
  <li><a href="http://hackage.haskell.org/package/free">http://hackage.haskell.org/package/free</a> # 推奨</li>
  <li><a href="http://hackage.haskell.org/package/control-monad-free">http://hackage.haskell.org/package/control-monad-free</a> # ?</li>
  <li><a href="http://hackage.haskell.org/package/transformers-free">http://hackage.haskell.org/package/transformers-free</a> # deprecated</li>
</ul>

<h3 id="operational-2">operational</h3>
<ul>
  <li><a href="http://hackage.haskell.org/package/operational">http://hackage.haskell.org/package/operational</a> # 一番人気</li>
  <li><a href="http://hackage.haskell.org/package/free-operational">http://hackage.haskell.org/package/free-operational</a> # freeを使った実装</li>
  <li><a href="http://hackage.haskell.org/package/minioperational">http://hackage.haskell.org/package/minioperational</a> # 上に挙げたoperationalの解説記事など書いてる人の再実装</li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96#.E3.83.A2.E3.83.8A.E3.83.89">https://ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96#.E3.83.A2.E3.83.8A.E3.83.89</a><a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>むしろmonadの定義としてはjoinの方が自然に見える<a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>functorの制約はhaskellのmonadの定義が悪い<a href="#fnref:3" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>あまり圏論に明るくないので少し怪しい<a href="#fnref:4" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>haskellのmonadがbindである理由かもしれない<a href="#fnref:5" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>圏論に精通していれば分かるのかどうかも分からない<a href="#fnref:6" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
</feed>
