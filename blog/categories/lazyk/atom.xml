<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lazyk | Higher Order うさぎ小屋]]></title>
  <link href="http://solorab.github.io/blog/categories/lazyk/atom.xml" rel="self"/>
  <link href="http://solorab.github.io/"/>
  <updated>2014-04-18T01:13:20+09:00</updated>
  <id>http://solorab.github.io/</id>
  <author>
    <name><![CDATA[そろうさぎ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[lazy kでquine書いた (iota記法)]]></title>
    <link href="http://solorab.github.io/blog/2014/04/17/quine-in-lazy-k/"/>
    <updated>2014-04-17T23:45:00+09:00</updated>
    <id>http://solorab.github.io/blog/2014/04/17/quine-in-lazy-k</id>
    <content type="html"><![CDATA[<ul>
  <li><a href="https://twitter.com/fumieval">@fumieval</a>氏のそれの再実装であって、独自性は特に無い
    <ul>
      <li><a href="http://d.hatena.ne.jp/fumiexcel/20120402/1333343067">文字列リテラルが無いLazy Kで黒魔術も力技も使わずにクワイン - fumievalの日記</a></li>
    </ul>
  </li>
  <li>自己満足性は非常に高いのでおすすめ</li>
  <li><a href="/blog/2014/04/17/how-to-write-a-quine/">前回記事</a>に沿って命名/実装した
    <ul>
      <li>もちろん先人の知恵も借りた</li>
    </ul>
  </li>
</ul>

<!-- more -->

<h2 id="code">code</h2>

<p>``` scheme
    (load “/path/to/lazier.scm”)
    (load “/path/to/prelude.scm”)
    (load “/path/to/prelude-numbers.scm”)</p>

<pre title="quine.scm"><code>(lazy-def 'map '(Y (lambda (recur f xs) (null? xs () (cons (f (car xs)) (recur f (cdr xs)))))))
(lazy-def 'append '(Y (lambda (recur xs ys) (null? xs ys (cons (car xs) (recur (cdr xs) ys))))))
(lazy-def 'concat '(Y (lambda (recur xs) (null? xs () (append (car xs) (recur (cdr xs)))))))

(lazy-def 'star 42) ; apply operator `*'
(lazy-def 'base 105) ; one point basis `i'
(lazy-def 'newline 10)

; if x then `*' else `i'
(lazy-def '(bit-&gt;program x) '(x star base))
(lazy-def '(str x) '(map bit-&gt;program x))

; #t -&gt; *i*i*ii
; #f -&gt; **i*i*ii*ii
; cons #t -&gt; ***i*i*i*ii**i*i*ii**i*i*i*ii***i*i*i*ii*ii**i*i*ii*i*i*ii*i*i*ii
; cons #f -&gt; ***i*i*i*ii**i*i*ii**i*i*i*ii***i*i*i*ii*ii**i*i*ii**i*i*ii*ii*i*i*ii
; () -&gt; **i*i*ii*i*i*ii
(lazy-def '(bit-&gt;data x)
          '(x (str ((lambda (t f) (t (t (t (t (f (t (f (t (f (t (f (f (t (t (f (t (f (t (f (f (t (t (f (t (f (t (f (t (f (f (t (t (t (f (t (f (t (f (t (f (f (t (f (f (t (t (f (t (f (t (f (f (t (f (t (f (t (f (f (t (f (t (f (t (f (f ()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (cons #t) (cons #f))) ; `` cons #t
              (str ((lambda (t f) (t (t (t (t (f (t (f (t (f (t (f (f (t (t (f (t (f (t (f (f (t (t (f (t (f (t (f (t (f (f (t (t (t (f (t (f (t (f (t (f (f (t (f (f (t (t (f (t (f (t (f (f (t (t (f (t (f (t (f (f (t (f (f (t (f (t (f (t (f (f ()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (cons #t) (cons #f))) ; `` cons #f
              ))
(lazy-def '(repr x) '(append (concat (map bit-&gt;data x)) (str ((lambda (t f) (t (t (f (t (f (t (f (f (t (f (t (f (t (f (f ())))))))))))))))) (cons #t) (cons #f)))))

(lazy-def '(main input) '(s (lambda (x y) (append (str x) (append y (append (cons newline ()) end-of-output)))) repr code))
(print-as-iota (laze 'main)) ```
</code></pre>

<p title="quine.scm"><code>sh
    #!/bin/sh
    code() {
        gosh quine.scm | sed -e 's/\[code\]$//'
    }
    quote() {
        # /*/` cons #t/ ; /i/` cons #f/
        tr -t '*i' 'tf' |
        sed -e 's/t/****i*i*i*ii**i*i*ii**i*i*i*ii***i*i*i*ii*ii**i*i*ii*i*i*ii*i*i*ii/g
        ; s/f/****i*i*i*ii**i*i*ii**i*i*i*ii***i*i*i*ii*ii**i*i*ii**i*i*ii*ii*i*i*ii/g
        ; s/$/**i*i*ii*i*i*ii/'
    }
    echo $(code)$(code | quote)
</code></p>

<p><code>sh
    $ ./quine.sh &gt; quine.lazy
    $ lazy quine.lazy &gt; out.lazy
    $ diff quine.lazy out.lazy
</code></p>

<h2 id="points">ハマりpoints</h2>

<h3 id="strrepr">strとreprの接合</h3>
<p>formatのような関数を用意するのは辛いので、単に<code>append</code>を使用したい</p>

<p>lazier.scmは解決できない識別子を<code>[code]</code>のようにbracketで囲って出力する<br />
しかし単に<code>((lambda (x) (append (str x) (repr x))) code)</code>とすると、<code>lambda</code>が簡約され、<code>[code]</code>が式の内部に2つ出現する<br />
これを回避するために<code>s</code>コンビネータを使い、<code>[code]</code>が変換後の式の末尾に登場するよう調整する</p>

<h3 id="section">実行が遅い</h3>
<p>2分かかった 諦めよう</p>

<h3 id="section-1">デバッグ</h3>
<p>何処が違うのか特定するのにひと手間要した<br />
最終的には、</p>

<ol>
  <li><code>s/(i+)/\1 /g</code>等として、適当に空白で分ける</li>
  <li><code>wdiff quine.lazy out.lazy | colordiff</code>として、単語単位diff+色</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lazk kでfizzbuzz書いた]]></title>
    <link href="http://solorab.github.io/blog/2014/04/13/fizzbuzz-in-lazy-k/"/>
    <updated>2014-04-13T02:27:48+09:00</updated>
    <id>http://solorab.github.io/blog/2014/04/13/fizzbuzz-in-lazy-k</id>
    <content type="html"><![CDATA[<ul>
  <li>妥協してschemeで書いた</li>
  <li>非常に簡単</li>
  <li>lazier.scmが強力すぎた</li>
  <li><code>$ grep -c '\&lt;[ski]\&gt;'</code>すると2 (2行 計3つ)</li>
  <li>4300byte</li>
</ul>

<p>``` scheme
    (load “/path/to/lazier.scm”)
    (load “/path/to/prelude.scm”)
    (load “/path/to/prelude-numbers.scm”)</p>

<pre><code>(lazy-def '(ifzero n x y) '(ifnonzero n y x))

(lazy-def '(pred n) '(lambda (f x) (n (lambda (p q) (q (p f))) (k x) i)))
(lazy-def '(- n m) '(m pred n))
(lazy-def 'mod '(Y (lambda (recur m n) ((if&lt; m n) m (recur (- m n) n)))))
(lazy-def 'div '(Y (lambda (recur m n) ((if&lt; m n) 0 (succ (recur (- m n) n))))))

(lazy-def 'map '(Y (lambda (recur f xs) (null? xs () (cons (f (car xs)) (recur f (cdr xs)))))))
(lazy-def 'append '(Y (lambda (recur xs ys) (null? xs ys (cons (car xs) (recur (cdr xs) ys))))))
(lazy-def 'concat '(Y (lambda (recur xs) (null? xs () (append (car xs) (recur (cdr xs)))))))

(lazy-def 'enum-from '(Y (lambda (recur n) (cons n (recur (succ n))))))
(lazy-def '(append-newline x) '(append x (cons 10 ())))

(lazy-def 'fizz '(cons 102 (cons 105 (cons 122 (cons 122 ())))))
(lazy-def 'buzz '(cons 98 (cons 117 (cons 122 (cons 122 ())))))
(lazy-def 'fizzbuzz '(append fizz buzz))

(lazy-def 'num-&gt;char '(+ 48))
(lazy-def 'posnum-&gt;string
          '(Y (lambda (recur n) ((ifzero n) ()
                                            (append (recur (div n 10)) (cons (num-&gt;char (mod n 10)) ()))))))
(lazy-def '(num-&gt;string n) '((ifnonzero n) (posnum-&gt;string n) (num-&gt;char 0)))

(lazy-def '(num-&gt;fizzbuzz n) '((ifzero (mod n 15) fizzbuzz
                                       (ifzero (mod n 5) buzz
                                               (ifzero (mod n 3) fizz
                                                       (num-&gt;string n))))))

(lazy-def '(main input) '(concat (map (o append-newline num-&gt;fizzbuzz) (enum-from 1))))
(print-as-unlambda (laze 'main)) ```
</code></pre>

<hr />

<dl>
  <dt>2014/04/17</dt>
  <dd>
    <ul>
      <li>Yコンビネータの無駄な再定義を除去</li>
      <li>map系関数のnil周りを修正</li>
      <li>入力の無視の方法を改良</li>
    </ul>
  </dd>
</dl>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lazy kでhello world書いた]]></title>
    <link href="http://solorab.github.io/blog/2014/04/09/hello-world-in-lazy-k/"/>
    <updated>2014-04-09T00:19:29+09:00</updated>
    <id>http://solorab.github.io/blog/2014/04/09/hello-world-in-lazy-k</id>
    <content type="html"><![CDATA[<ul>
  <li>“hello world”</li>
  <li>9000byteぐらい</li>
  <li>できるだけ自力で書いた</li>
  <li>CPPを使用 (<code>gcc -E</code>)</li>
  <li><a href="/blog/2014/04/05/lambda-calculus-for-great-good/">ラムダ計算について調べた</a>のを有効活用した</li>
  <li>楽しい</li>
</ul>

<!-- more -->

<h2 id="lazy-k-is-">Lazy K is 何</h2>
<ul>
  <li><a href="http://legacy.e.tir.jp/wiliki?%cb%dd%cc%f5%3a%a5%d7%a5%ed%a5%b0%a5%e9%a5%df%a5%f3%a5%b0%b8%c0%b8%ecLazy_K">翻訳:プログラミング言語Lazy_K</a></li>
  <li><a href="http://blog.livedoor.jp/dankogai/archives/51524324.html">404 Blog Not Found:Math - 言語はどこまで小さくなれるか - (unlambda|iota|jot) のすすめ</a>
    <ul>
      <li>ここのpatchあてて-fpermissiveしたらcompile通った</li>
    </ul>
  </li>
  <li>すごそう</li>
  <li>かっこいい</li>
</ul>

<h2 id="section">入出力</h2>
<ul>
  <li>プログラムに引数として標準入力が与えられ、返り値が標準出力に出る</li>
  <li>つまり <code>getContents &gt;&gt;= (pure . main) &gt;&gt;= putStr</code></li>
  <li>ただし文字列はチャーチ数のスコットエンコーディングのリスト
    <ul>
      <li><a href="http://d.hatena.ne.jp/syamino/20120524/p1">ラムダ計算で代数的データ型を表現する方法 - @syamino はてなダイアリー</a></li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="ignoreinput">ignore_input</h2>

<p><code>c
    #define ignore_input k
</code></p>

<ul>
  <li>code頭に置いて、入力を無視する</li>
  <li><code>k PROGRAM INPUT -&gt; PROGRAM</code></li>
</ul>

<h2 id="section-1">簡単な関数</h2>
<p><code>c
    #define id (skk)
    #define true k
    #define false (ki)
    #define zero false
    #define one id
</code></p>

<p>何とか書ける</p>

<h2 id="car-cdr--head-tail">car cdr / head tail</h2>
<ul>
  <li><code>car list = list true</code></li>
  <li><code>cdr list = list false</code></li>
</ul>

<p>しかし</p>

<p><code>
    \ x y . y x
</code></p>

<p>が書けない</p>

<p>とりあえず文字列を持ってきて<code>true</code>/<code>false</code>を試してみる</p>

<p><a href="https://ja.wikipedia.org/wiki/Hello_world%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E4%B8%80%E8%A6%A7#Lazy_K">Hello worldプログラムの一覧 # Lazy_K - Wikipedia</a></p>

<p><code>c
    #define helloworld ``s``si`k</code>s<code>sss</code><code>s</code><code>s</code>ks<code>ssi</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k` \
       </code>ss<code>s</code>ss<code>ki</code><code>ss</code><code>ss`ss</code>ss<code>ki</code><code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``si``ss``ss`ki</code> \
        ss<code>s</code><code>sss</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k</code><code>s</code><code>si</code><code>ss</code><code>ss</code>ki<code>ss`s``sss``ss`ki` \
        `s`ksk`k``s``si`k</code>ss<code>s</code>sss<code>ss</code><code>ss</code>ss<code>ss`ki</code>s<code>ksk</code>k<code>s</code>si<code>k</code><code>ss` \
        `ss</code>s<code>sss</code>s<code>sss</code>ss<code>ki</code><code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``ss</code>ssi<code>ss`ki</code>ss<code>ki</code> \
        <code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``si``ss``s``sss``ss`ki``ss</code>ss<code>ssi</code>ss<code>ki</code><code>s</code>ksk<code> \
        k</code><code>s</code><code>si</code>k<code>ss``s``sss``ss</code>ss<code>ss</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k</code><code>ss</code><code>ss</code><code>ss \
        </code><code>ss</code><code>s</code><code>sss</code><code>ss</code><code>ss`ss</code>ss<code>ki</code><code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``si``ss``ss`ki</code>ss \
        <code>s</code><code>sss</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k</code><code>s</code><code>ss</code>ki<code>ss</code><code>ss</code>ss<code>ss`ki</code>s<code>ksk</code>k<code>\
        s</code>si<code>k</code><code>ss</code><code>ss</code>ss<code>ss`ki</code>s<code>ksk</code>k<code>k</code><code>sii</code><code>sii</code><code>s</code><code>s</code>kski
```</p>

<p><code>c
    ignore_input (helloworld false)
    ##=&gt; ello, world
</code></p>

<p>動く</p>

<h2 id="t">T[]変換</h2>
<ul>
  <li>救世主現る</li>
  <li><a href="http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E8%AB%96%E7%90%86#S-K\_basis.E3.81.AE.E5.AE.8C.E5.85.A8.E6.80.A7">コンビネータ論理 # T[] 変換について - Wikipedia</a></li>
  <li>わりと簡単な<code>lambda式 -&gt; skiコンビネータ</code>の変換</li>
  <li>eta簡約もすると短くなる <code>(s (k X) i) -&gt; X</code></li>
</ul>

<h2 id="x-y-y-x">\ x y. y x</h2>
<p>wikipediaの例と同じだけど、自分でも変換する</p>

<p><code>c
    #define rev (s (k (s i)) k)
</code></p>

<h2 id="car--cdr">car / cdr</h2>
<p><code>\ x y. y x</code> ができたので作れるように</p>

<p><code>c
    #define car (rev true)
    #define cdr (rev false)
</code></p>

<p><code>c
    ignore_input (cdr helloworld)
    ##=&gt; ello, world
</code></p>

<h2 id="succ">succ</h2>
<ul>
  <li><code>\ n f x. f (n f x)</code> も変換</li>
  <li>結構頑張る</li>
</ul>

<p><code>c
    #define succ (s (k (s (s (k s) k))) (s (s (k s) k) (k i)))
</code></p>

<h2 id="cons">cons</h2>
<ul>
  <li><code>succ</code>だけあっても使えないので<code>cons</code></li>
  <li>lazy-kはスコットエンコーディング</li>
  <li><code>\ x y z . z x y</code></li>
</ul>

<p><code>c
    #define cons (s (s (k s) (s (k k) (s (k s) (s (k (s i)) (s (k k) i))))) (k (s (k k) i)))
</code></p>

<p><code>c
    #define cons (s (s (k s) (s (k k) (s (k s) (s (k (s i)) k)))) (k k))
    ##=&gt; Iello, world
</code></p>

<h2 id="section-2">演算</h2>
<p><code>
    plus = \ m n. m succ n
    mult = \ m n f. m (n f)
    pow = \ m n n (mult m) one # 不要
</code></p>

<p><code>c
    #define plus (s (s (k s) (s (k k) (s i (k succ)))) (k i))
    #define mult (s (s (k s) (s (k k) (s (k s) k))) (k i))
    #define pow (s (s (k s) (s (k (s i)) (s (k k) mult))) (k (k one)))
</code></p>

<ul>
  <li>手作業で丁寧に変換</li>
</ul>

<h2 id="hello-world">hello world</h2>

<h3 id="section-3">出力すべき数を確認する</h3>

<p>``` sh
    $ ghc -e ‘print $ map ord “hello world”’
    [104,101,108,108,111,32,119,111,114,108,100]</p>

<pre><code>$ ghc -e 'print $ map (($ "") . showIntAtBase 2 intToDigit . ord) "hello world"'
["1101000","1100101","1101100","1101100","1101111","100000","1110111","1101111","1110010","1101100","1100100"] ```
</code></pre>

<h3 id="section-4">数字を定義</h3>
<p><code>c
    #define two (s (s (k s) k) i) # 無駄な変換
    #define double (mult two)
    #define four (double two)
    #define eight (double four)
    #define sixteen (double eight)
    #define thirtytwo (double sixteen)
    #define sixtyfour (double thirtytwo)
    #define eof (pow four four)
</code></p>

<ul>
  <li>lazy-kは<code>256</code>をもって<code>eof</code>とする</li>
  <li>2進数万歳</li>
  <li>2は変換しておいた</li>
</ul>

<h3 id="section-5">完成</h3>

<p><code>scheme
    ignore_input
    (cons (plus sixtyfour (plus thirtytwo eight)) # h
    (cons (plus sixtyfour (plus thirtytwo (plus four one))) # e
    (cons (plus sixtyfour (plus thirtytwo (plus eight four))) # l
    (cons (plus sixtyfour (plus thirtytwo (plus eight four))) # l
    (cons (plus sixtyfour (plus thirtytwo (plus eight (plus four (plus two one))))) # o
    (cons thirtytwo # ' '
    (cons (plus sixtyfour (plus thirtytwo (plus sixteen (plus four (plus two one))))) # w
    (cons (plus sixtyfour (plus thirtytwo (plus eight (plus four (plus two one))))) # o
    (cons (plus sixtyfour (plus thirtytwo (plus sixteen two))) # r
    (cons (plus sixtyfour (plus thirtytwo (plus eight four))) # l
    (cons (plus sixtyfour (plus thirtytwo four)) # e
    (cons eof k))))))))))))
</code></p>

<p><code>sh
    $ gcc -E a.lazy.cpp &gt; a.lazy &amp;&amp; echo hoge | ./lazy a.lazy
    hello world
</code></p>

<hr />

<dl>
  <dt>2014/04/11</dt>
  <dd><code>two</code>の定義が抜けてたので修正</dd>
</dl>
]]></content>
  </entry>
  
</feed>
