<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: parsec | Higher Order うさぎ小屋]]></title>
  <link href="http://solorab.github.io/blog/categories/parsec/atom.xml" rel="self"/>
  <link href="http://solorab.github.io/"/>
  <updated>2014-04-11T08:17:03+09:00</updated>
  <id>http://solorab.github.io/</id>
  <author>
    <name><![CDATA[そろうさぎ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[parsecで非決定的パース]]></title>
    <link href="http://solorab.github.io/blog/2014/01/25/non-deterministic-parsing-with-parsec/"/>
    <updated>2014-01-25T18:28:27+09:00</updated>
    <id>http://solorab.github.io/blog/2014/01/25/non-deterministic-parsing-with-parsec</id>
    <content type="html"><![CDATA[<p>ざっくりparseして、出力を<code>filter</code>や<code>head</code>で加工したかった</p>

<p><code>haskell
    fork :: [ParsecT s u [] a] -&gt; ParsecT s u [] a
    fork = join . lift
</code></p>

<p>※ list-monadで非決定的計算できるのは、parsecに限った話ではない</p>

<!-- more -->

<p><code>ParsecT</code>をlist-monadと合成するだけなので、上のように定義する<br />
型注釈なしなら<code>join . lift :: (Monad (t m), Monad m, MonadTrans t) =&gt; m (t m a) -&gt; t m a</code></p>

<p>非決定的の厳密な定義を知らないが、chooseとfail<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>が使えるので非決定的と呼んでいいはず<br />
ただし<code>fail = fork []</code>であって、<code>Prelude.fail</code>(<code>Text.Parsec.parserFail</code>)ではない</p>

<h2 id="section">例</h2>

<p>``` haskell
    p = try p’ &lt;|&gt; many1 anyChar where
        p’ = do
            x &lt;- manyTill anyChar $ char ‘+’
            fork
                [ return x
                , (x ++) &lt;$&gt; p
                ]</p>

<pre><code>&gt;&gt;&gt; runParserT p () "input" "a+b+c" where
[Right "a",Right "ab",Right "abc"] ```
</code></pre>

<p>``` haskell
    q = try q’ &lt;|&gt; fork [] where
        q’ = do
            x &lt;- p
            fork
                [ return [x]
                , (x :) &lt;$&gt; q
                ]</p>

<pre><code>&gt;&gt;&gt; runParserT p () "input" "a+b+c" where
[Right ["a"],Right ["a","b"],Right ["a","b","c"],Right ["a","bc"],Right ["ab"],Right ["ab","c"],Right ["abc"]] ```
</code></pre>

<p><code>ここではきものをぬいでください</code>のような文をparseするとき便利なんじゃないでしょうか</p>

<h2 id="section-1">参考</h2>

<ul>
  <li><a href="http://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/nondeterminism.html">On Lisp — 非決定性</a></li>
  <li><a href="http://hooki.blog23.fc2.com/blog-entry-74.html">雑草ブログ Listモナドで非決定的計算をしよう</a></li>
</ul>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>On Lispの説明による<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Int]をparsecでパースする]]></title>
    <link href="http://solorab.github.io/blog/2014/01/25/parse-list-of-ints-with-parsec/"/>
    <updated>2014-01-25T17:50:35+09:00</updated>
    <id>http://solorab.github.io/blog/2014/01/25/parse-list-of-ints-with-parsec</id>
    <content type="html"><![CDATA[<p>``` haskell
    »&gt; parse (many even’) “numbers” [0,0,2,4,9999]
    Right [0,0,2,4]</p>

<pre><code>&gt;&gt;&gt; parse (many (zero &lt;|&gt; odd') &gt;&gt; eof) "numbers" [0,1,1,3,5,8]
Left "numbers" (line 1, column 6):
unexpected 8
expecting zero, odd or end of input ```
</code></pre>

<p><code>[Int]</code>だとおふざけだが、複雑な何かだと便利かもしれない<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<!-- more -->

<p><code>Monad m =&gt; Stream [tok] m tok</code>とあるので、<code>list</code>に包めば何でもparse可能に見える<br />
しかし<code>Stream s m Char =&gt;</code>制約の代わりに<code>(Stream s m tok, Eq tok) =&gt;</code>なものが<del>見当たらない</del><br />
標準の<code>satisfy</code>さえ<code>:: Stream s m Char =&gt; (Char -&gt; Bool) -&gt; ParsecT s u m Char</code>と、<code>Char</code>しか受け入れてくれない<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup><br />
<del>仕方がないので</del><ins>仕方なくなかった(<a href="#ins">追記</a>)</ins><code>satisfy</code>を再定義する</p>

<p>``` haskell
    updatePos :: SourcePos -&gt; Column -&gt; SourcePos
    updatePos p n = setSourceColumn p (sourceColumn p + n)</p>

<pre><code>satisfy' :: (Stream s m t, Show t) =&gt; (t -&gt; Bool) -&gt; ParsecT s u m t
satisfy' f = tokenPrim show
    (\ pos _ _ -&gt; updatePos pos 1)
    (\ c -&gt; if f c then Just c else Nothing) ```
</code></pre>

<p><code>Text.Parsec.Char</code>のほぼ全ての関数<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>は<code>satisfy</code>経由で定義されているので、<br />
<code>Text.Parsec.Int</code>を作ることが可能になる</p>

<p><code>haskell
    zero :: (Num a, Eq a, Stream s m a, Show a) =&gt; ParsecT s u m a
    zero = satisfy' (== 0) &lt;?&gt; "zero"
    even', odd' :: (Integral a, Stream s m a, Show a) =&gt; ParsecT s u m a
    even' = satisfy' even &lt;?&gt; "even"
    odd' = satisfy' odd &lt;?&gt; "odd"
</code></p>

<h2 id="section">参考</h2>
<ul>
  <li><a href="http://hackage.haskell.org/package/parsec">Hackage: parsec: Monadic parser combinators</a></li>
  <li><a href="http://qiita.com/hiratara/items/a451b04fb19bfcc7ff08">Haskell - Parsecのソースちら見(3) - Qiita</a></li>
</ul>

<h2 id="ins">追記</h2>
<p>定義されてた</p>

<p><a href="http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Combinator.html#v:anyToken">Text.Parsec.Combinator.anyToken</a><br />
<code>anyToken :: (Stream s m t, Show t) =&gt; ParsecT s u m t</code></p>

<p>なので</p>

<p><code>haskell
    satisfy' f = try $ lookAhead (anyToken &gt;&gt;= (\ x -&gt; if f x then return x else unexpected $ show x))
</code>
としても良い</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>便利でないかもしれない<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>parser-libraryなので当然<a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p><code>Text.Parsec.Char.string</code>以外の全て<a href="#fnref:3" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
</feed>
