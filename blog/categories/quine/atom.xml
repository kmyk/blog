<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: quine | Higher Order うさぎ小屋]]></title>
  <link href="http://solorab.github.io/blog/categories/quine/atom.xml" rel="self"/>
  <link href="http://solorab.github.io/"/>
  <updated>2014-04-18T01:13:20+09:00</updated>
  <id>http://solorab.github.io/</id>
  <author>
    <name><![CDATA[そろうさぎ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[lazy kでquine書いた (iota記法)]]></title>
    <link href="http://solorab.github.io/blog/2014/04/17/quine-in-lazy-k/"/>
    <updated>2014-04-17T23:45:00+09:00</updated>
    <id>http://solorab.github.io/blog/2014/04/17/quine-in-lazy-k</id>
    <content type="html"><![CDATA[<ul>
  <li><a href="https://twitter.com/fumieval">@fumieval</a>氏のそれの再実装であって、独自性は特に無い
    <ul>
      <li><a href="http://d.hatena.ne.jp/fumiexcel/20120402/1333343067">文字列リテラルが無いLazy Kで黒魔術も力技も使わずにクワイン - fumievalの日記</a></li>
    </ul>
  </li>
  <li>自己満足性は非常に高いのでおすすめ</li>
  <li><a href="/blog/2014/04/17/how-to-write-a-quine/">前回記事</a>に沿って命名/実装した
    <ul>
      <li>もちろん先人の知恵も借りた</li>
    </ul>
  </li>
</ul>

<!-- more -->

<h2 id="code">code</h2>

<p>``` scheme
    (load “/path/to/lazier.scm”)
    (load “/path/to/prelude.scm”)
    (load “/path/to/prelude-numbers.scm”)</p>

<pre title="quine.scm"><code>(lazy-def 'map '(Y (lambda (recur f xs) (null? xs () (cons (f (car xs)) (recur f (cdr xs)))))))
(lazy-def 'append '(Y (lambda (recur xs ys) (null? xs ys (cons (car xs) (recur (cdr xs) ys))))))
(lazy-def 'concat '(Y (lambda (recur xs) (null? xs () (append (car xs) (recur (cdr xs)))))))

(lazy-def 'star 42) ; apply operator `*'
(lazy-def 'base 105) ; one point basis `i'
(lazy-def 'newline 10)

; if x then `*' else `i'
(lazy-def '(bit-&gt;program x) '(x star base))
(lazy-def '(str x) '(map bit-&gt;program x))

; #t -&gt; *i*i*ii
; #f -&gt; **i*i*ii*ii
; cons #t -&gt; ***i*i*i*ii**i*i*ii**i*i*i*ii***i*i*i*ii*ii**i*i*ii*i*i*ii*i*i*ii
; cons #f -&gt; ***i*i*i*ii**i*i*ii**i*i*i*ii***i*i*i*ii*ii**i*i*ii**i*i*ii*ii*i*i*ii
; () -&gt; **i*i*ii*i*i*ii
(lazy-def '(bit-&gt;data x)
          '(x (str ((lambda (t f) (t (t (t (t (f (t (f (t (f (t (f (f (t (t (f (t (f (t (f (f (t (t (f (t (f (t (f (t (f (f (t (t (t (f (t (f (t (f (t (f (f (t (f (f (t (t (f (t (f (t (f (f (t (f (t (f (t (f (f (t (f (t (f (t (f (f ()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (cons #t) (cons #f))) ; `` cons #t
              (str ((lambda (t f) (t (t (t (t (f (t (f (t (f (t (f (f (t (t (f (t (f (t (f (f (t (t (f (t (f (t (f (t (f (f (t (t (t (f (t (f (t (f (t (f (f (t (f (f (t (t (f (t (f (t (f (f (t (t (f (t (f (t (f (f (t (f (f (t (f (t (f (t (f (f ()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (cons #t) (cons #f))) ; `` cons #f
              ))
(lazy-def '(repr x) '(append (concat (map bit-&gt;data x)) (str ((lambda (t f) (t (t (f (t (f (t (f (f (t (f (t (f (t (f (f ())))))))))))))))) (cons #t) (cons #f)))))

(lazy-def '(main input) '(s (lambda (x y) (append (str x) (append y (append (cons newline ()) end-of-output)))) repr code))
(print-as-iota (laze 'main)) ```
</code></pre>

<p title="quine.scm"><code>sh
    #!/bin/sh
    code() {
        gosh quine.scm | sed -e 's/\[code\]$//'
    }
    quote() {
        # /*/` cons #t/ ; /i/` cons #f/
        tr -t '*i' 'tf' |
        sed -e 's/t/****i*i*i*ii**i*i*ii**i*i*i*ii***i*i*i*ii*ii**i*i*ii*i*i*ii*i*i*ii/g
        ; s/f/****i*i*i*ii**i*i*ii**i*i*i*ii***i*i*i*ii*ii**i*i*ii**i*i*ii*ii*i*i*ii/g
        ; s/$/**i*i*ii*i*i*ii/'
    }
    echo $(code)$(code | quote)
</code></p>

<p><code>sh
    $ ./quine.sh &gt; quine.lazy
    $ lazy quine.lazy &gt; out.lazy
    $ diff quine.lazy out.lazy
</code></p>

<h2 id="points">ハマりpoints</h2>

<h3 id="strrepr">strとreprの接合</h3>
<p>formatのような関数を用意するのは辛いので、単に<code>append</code>を使用したい</p>

<p>lazier.scmは解決できない識別子を<code>[code]</code>のようにbracketで囲って出力する<br />
しかし単に<code>((lambda (x) (append (str x) (repr x))) code)</code>とすると、<code>lambda</code>が簡約され、<code>[code]</code>が式の内部に2つ出現する<br />
これを回避するために<code>s</code>コンビネータを使い、<code>[code]</code>が変換後の式の末尾に登場するよう調整する</p>

<h3 id="section">実行が遅い</h3>
<p>2分かかった 諦めよう</p>

<h3 id="section-1">デバッグ</h3>
<p>何処が違うのか特定するのにひと手間要した<br />
最終的には、</p>

<ol>
  <li><code>s/(i+)/\1 /g</code>等として、適当に空白で分ける</li>
  <li><code>wdiff quine.lazy out.lazy | colordiff</code>として、単語単位diff+色</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[quineを書く一般的な方法]]></title>
    <link href="http://solorab.github.io/blog/2014/04/17/how-to-write-a-quine/"/>
    <updated>2014-04-17T23:44:24+09:00</updated>
    <id>http://solorab.github.io/blog/2014/04/17/how-to-write-a-quine</id>
    <content type="html"><![CDATA[<ul>
  <li>言語固有の機能を使い特殊な方法でquineする場合は考えない</li>
  <li>とりあえず書ければいい人向け</li>
</ul>

<!-- more -->

<h2 id="section">外観</h2>
<p>quineは</p>

<p><code>python
    eval("program(data)") #=&gt; "program(data)"
</code></p>

<p>となる<code>program</code>部と<code>data</code>部に分けられる</p>

<h2 id="section-1">詳細</h2>
<p><code>program</code>と<code>data</code>はたいてい以下のように動く<br />
python風言語で示す</p>

<p><code>python
    .   eval("program(data)")
    -&gt;  program(data)
    =   print(format(str(data), repr(data)))
    -&gt;  print(format("program", "data"))
    -&gt;  print("program(data)")
    #=&gt; "program(data)"
</code></p>

<h2 id="section-2">実装</h2>
<p>つまり、基本的に、実装/決定すべきは、</p>

<ul>
  <li>適当な入力<code>data</code></li>
  <li>変換関数<code>str : data -&gt; "program"</code></li>
  <li>変換関数<code>repr : data -&gt; "data"</code></li>
  <li>結合関数<code>format : ("program", "data") -&gt; "program(data)"</code></li>
  <li>適当な出力<code>print</code></li>
</ul>

<p>である<br />
<code>str</code>,<code>repr</code>,<code>format</code>等の役割の境界は曖昧である
言語によっては<code>print</code>と<code>format</code>に<code>printf</code>を採用し1つにまとめるなどできる</p>

<p>これらはたいてい、</p>

<ul>
  <li><code>data = quote("program")</code></li>
  <li><code>str = id</code></li>
  <li><code>repr = quote</code></li>
  <li><code>format = append, format</code></li>
  <li><code>print = print</code></li>
</ul>

<p>が使われる<br />
実装量が少なく楽だからである</p>

<p>また、一般的な<code>print</code>が存在しない言語では、好みの方法で出力すれば良い</p>

<h2 id="section-3">例</h2>

<h3 id="haskell">分かりやすい例 haskell</h3>

<p><code>show</code>が言語内に有るので非常に楽である</p>

<p><code>haskell
    main = putStrLn $ (\ x -&gt; x ++ show x) "main = putStrLn $ (\\ x -&gt; x ++ show x) "
</code></p>

<ul>
  <li><code>data = "main = putStrLn $ (\\ x -&gt; x ++ show x) "</code></li>
  <li><code>str = id</code> (省略)</li>
  <li><code>repr = show</code></li>
  <li><code>format = (++)</code></li>
  <li><code>print = putStrLn</code></li>
</ul>

<h3 id="python">少し長い例 python</h3>

<p>標準関数の<code>repr</code>は高機能すぎて、quineには利用できなかったので<code>repr</code>を実装<br />
接続には<code>{}</code>で指定して<code>format</code>を使用</p>

<p><code>python
    #!/usr/bin/python3
    show = lambda q: '"""' + q.replace('\\','\\\\').replace('\"','\\\"') + '"""'
    q = """#!/usr/bin/python3
    show = lambda q: '\"\"\"' + q.replace('\\\\','\\\\\\\\').replace('\\\"','\\\\\\\"') + '\"\"\"'
    q = {}
    print(q.format(show(q)))"""
    print(q.format(show(q)))
</code></p>

<h3 id="lazyk-iota">一般的な例 lazyk (iota)</h3>
<p><a href="/blog/2014/04/17/quine-in-lazy-k/">次の記事</a></p>

<h2 id="section-4">参考</h2>
<ul>
  <li><a href="http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AF%E3%82%A4%E3%83%B3_\(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0\)">クワイン (プログラミング) - Wikipedia</a></li>
  <li><a href="http://d.hatena.ne.jp/fumiexcel/20120402/1333343067">文字列リテラルが無いLazy Kで黒魔術も力技も使わずにクワイン - fumievalの日記</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
