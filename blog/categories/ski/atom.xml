<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ski | Higher Order うさぎ小屋]]></title>
  <link href="http://solorab.github.io/blog/categories/ski/atom.xml" rel="self"/>
  <link href="http://solorab.github.io/"/>
  <updated>2014-04-11T08:17:03+09:00</updated>
  <id>http://solorab.github.io/</id>
  <author>
    <name><![CDATA[そろうさぎ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[lazy kでhello world書いた]]></title>
    <link href="http://solorab.github.io/blog/2014/04/09/hello-world-in-lazy-k/"/>
    <updated>2014-04-09T00:19:29+09:00</updated>
    <id>http://solorab.github.io/blog/2014/04/09/hello-world-in-lazy-k</id>
    <content type="html"><![CDATA[<ul>
  <li>“hello world”</li>
  <li>9000byteぐらい</li>
  <li>できるだけ自力で書いた</li>
  <li>CPPを使用 (<code>gcc -E</code>)</li>
  <li><a href="/blog/2014/04/05/lambda-calculus-for-great-good/">ラムダ計算について調べた</a>のを有効活用した</li>
  <li>楽しい</li>
</ul>

<!-- more -->

<h2 id="lazy-k-is-">Lazy K is 何</h2>
<ul>
  <li><a href="http://legacy.e.tir.jp/wiliki?%cb%dd%cc%f5%3a%a5%d7%a5%ed%a5%b0%a5%e9%a5%df%a5%f3%a5%b0%b8%c0%b8%ecLazy_K">翻訳:プログラミング言語Lazy_K</a></li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[404 Blog Not Found:Math - 言語はどこまで小さくなれるか - (unlambda</td>
          <td>iota</td>
          <td>jot) のすすめ](http://blog.livedoor.jp/dankogai/archives/51524324.html)</td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li>ここのpatchあてて-fpermissiveしたらcompile通った</li>
    </ul>
  </li>
  <li>すごそう</li>
  <li>かっこいい</li>
</ul>

<h2 id="section">入出力</h2>
<ul>
  <li>プログラムに引数として標準入力が与えられ、返り値が標準出力に出る</li>
  <li>つまり <code>getContents &gt;&gt;= (pure . main) &gt;&gt;= putStr</code></li>
  <li>ただし文字列はチャーチ数のスコットエンコーディングのリスト
    <ul>
      <li><a href="http://d.hatena.ne.jp/syamino/20120524/p1">ラムダ計算で代数的データ型を表現する方法 - @syamino はてなダイアリー</a></li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="ignoreinput">ignore_input</h2>

<p><code>c
    #define ignore_input k
</code></p>

<ul>
  <li>code頭に置いて、入力を無視する</li>
  <li><code>k PROGRAM INPUT -&gt; PROGRAM</code></li>
</ul>

<h2 id="section-1">簡単な関数</h2>
<p><code>c
    #define id (skk)
    #define true k
    #define false (ki)
    #define zero false
    #define one id
</code></p>

<p>何とか書ける</p>

<h2 id="car-cdr--head-tail">car cdr / head tail</h2>
<ul>
  <li><code>car list = list true</code></li>
  <li><code>cdr list = list false</code></li>
</ul>

<p>しかし</p>

<p><code>
    \ x y . y x
</code></p>

<p>が書けない</p>

<p>とりあえず文字列を持ってきて<code>true</code>/<code>false</code>を試してみる</p>

<p><a href="https://ja.wikipedia.org/wiki/Hello_world%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E4%B8%80%E8%A6%A7#Lazy_K">Hello worldプログラムの一覧 # Lazy_K - Wikipedia</a></p>

<p><code>c
#define helloworld ``s``si`k</code>s<code>sss</code><code>s</code><code>s</code>ks<code>ssi</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k` \
   </code>ss<code>s</code>ss<code>ki</code><code>ss</code><code>ss`ss</code>ss<code>ki</code><code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``si``ss``ss`ki</code> \
    ss<code>s</code><code>sss</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k</code><code>s</code><code>si</code><code>ss</code><code>ss</code>ki<code>ss`s``sss``ss`ki` \
    `s`ksk`k``s``si`k</code>ss<code>s</code>sss<code>ss</code><code>ss</code>ss<code>ss`ki</code>s<code>ksk</code>k<code>s</code>si<code>k</code><code>ss` \
    `ss</code>s<code>sss</code>s<code>sss</code>ss<code>ki</code><code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``ss</code>ssi<code>ss`ki</code>ss<code>ki</code> \
    <code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``si``ss``s``sss``ss`ki``ss</code>ss<code>ssi</code>ss<code>ki</code><code>s</code>ksk<code> \
    k</code><code>s</code><code>si</code>k<code>ss``s``sss``ss</code>ss<code>ss</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k</code><code>ss</code><code>ss</code><code>ss \
    </code><code>ss</code><code>s</code><code>sss</code><code>ss</code><code>ss`ss</code>ss<code>ki</code><code>s</code>ksk<code>k</code><code>s</code><code>si</code>k<code>s``si``ss``ss`ki</code>ss \
    <code>s</code><code>sss</code><code>ss</code>ki<code>s`ksk`k</code>s<code>si`k</code><code>s</code><code>ss</code>ki<code>ss</code><code>ss</code>ss<code>ss`ki</code>s<code>ksk</code>k<code>\
    s</code>si<code>k</code><code>ss</code><code>ss</code>ss<code>ss`ki</code>s<code>ksk</code>k<code>k</code><code>sii</code><code>sii</code><code>s</code><code>s</code>kski
```</p>

<p><code>c
    ignore_input (helloworld false)
    ##=&gt; ello, world
</code></p>

<p>動く</p>

<h2 id="t">T[]変換</h2>
<ul>
  <li>救世主現る</li>
  <li><a href="http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E8%AB%96%E7%90%86#S-K\_basis.E3.81.AE.E5.AE.8C.E5.85.A8.E6.80.A7">コンビネータ論理 # T[] 変換について - Wikipedia</a></li>
  <li>わりと簡単な<code>lambda式 -&gt; skiコンビネータ</code>の変換</li>
  <li>eta簡約もすると短くなる <code>(s (k X) i) -&gt; X</code></li>
</ul>

<h2 id="x-y-y-x">\ x y. y x</h2>
<p>wikipediaの例と同じだけど、自分でも変換する</p>

<p><code>c
    #define rev (s (k (s i)) k)
</code></p>

<h2 id="car--cdr">car / cdr</h2>
<p><code>\ x y. y x</code> ができたので作れるように</p>

<p><code>c
    #define car (rev true)
    #define cdr (rev false)
</code></p>

<p><code>c
    ignore_input (cdr helloworld)
    ##=&gt; ello, world
</code></p>

<h2 id="succ">succ</h2>
<ul>
  <li><code>\ n f x. f (n f x)</code> も変換</li>
  <li>結構頑張る</li>
</ul>

<p><code>c
    #define succ (s (k (s (s (k s) k))) (s (s (k s) k) (k i)))
</code></p>

<h2 id="cons">cons</h2>
<ul>
  <li><code>succ</code>だけあっても使えないので<code>cons</code></li>
  <li>lazy-kはスコットエンコーディング</li>
  <li><code>\ x y z . z x y</code></li>
</ul>

<p><code>c
    #define cons (s (s (k s) (s (k k) (s (k s) (s (k (s i)) (s (k k) i))))) (k (s (k k) i)))
</code></p>

<p><code>c
    #define cons (s (s (k s) (s (k k) (s (k s) (s (k (s i)) k)))) (k k))
    ##=&gt; Iello, world
</code></p>

<h2 id="section-2">演算</h2>
<p><code>
    plus = \ m n. m succ n
    mult = \ m n f. m (n f)
    pow = \ m n n (mult m) one # 不要
</code></p>

<p><code>c
    #define plus (s (s (k s) (s (k k) (s i (k succ)))) (k i))
    #define mult (s (s (k s) (s (k k) (s (k s) k))) (k i))
    #define pow (s (s (k s) (s (k (s i)) (s (k k) mult))) (k (k one)))
</code></p>

<ul>
  <li>手作業で丁寧に変換</li>
</ul>

<h2 id="hello-world">hello world</h2>

<h3 id="section-3">出力すべき数を確認する</h3>

<p>``` sh
    $ ghc -e ‘print $ map ord “hello world”’
    [104,101,108,108,111,32,119,111,114,108,100]</p>

<pre><code>$ ghc -e 'print $ map (($ "") . showIntAtBase 2 intToDigit . ord) "hello world"'
["1101000","1100101","1101100","1101100","1101111","100000","1110111","1101111","1110010","1101100","1100100"] ```
</code></pre>

<h3 id="section-4">数字を定義</h3>
<p><code>c
    #define double (mult two)
    #define four (double two)
    #define eight (double four)
    #define sixteen (double eight)
    #define thirtytwo (double sixteen)
    #define sixtyfour (double thirtytwo)
    #define eof (pow four four)
</code></p>

<ul>
  <li>lazy-kは<code>256</code>をもって<code>eof</code>とする</li>
  <li>2進数万歳</li>
</ul>

<h3 id="section-5">完成</h3>

<p><code>scheme
    ignore_input
    (cons (plus sixtyfour (plus thirtytwo eight)) # h
    (cons (plus sixtyfour (plus thirtytwo (plus four one))) # e
    (cons (plus sixtyfour (plus thirtytwo (plus eight four))) # l
    (cons (plus sixtyfour (plus thirtytwo (plus eight four))) # l
    (cons (plus sixtyfour (plus thirtytwo (plus eight (plus four (plus two one))))) # o
    (cons thirtytwo # ' '
    (cons (plus sixtyfour (plus thirtytwo (plus sixteen (plus four (plus two one))))) # w
    (cons (plus sixtyfour (plus thirtytwo (plus eight (plus four (plus two one))))) # o
    (cons (plus sixtyfour (plus thirtytwo (plus sixteen two))) # r
    (cons (plus sixtyfour (plus thirtytwo (plus eight four))) # l
    (cons (plus sixtyfour (plus thirtytwo four)) # e
    (cons eof k))))))))))))
</code></p>

<p><code>sh
    $ gcc -E a.lazy.cpp &gt; a.lazy &amp;&amp; echo hoge | ./lazy a.lazy
    hello world
</code></p>
]]></content>
  </entry>
  
</feed>
