---
layout: post
alias: "/blog/2016/12/16/yuki-463/"
date: "2016-12-16T22:13:20+09:00"
title: "Yukicoder No.463 é­”æ³•ä½¿ã„ã®ã™ã”ã‚ãğŸ²"
tags: [ "competitive", "writeup", "yukicoder", "dp", "matrix", "gaussian-elimination" ]
"target_url": [ "http://yukicoder.me/problems/no/463" ]
---

DPã«è¦‹ã›ã‹ã‘ã¦ãã†ã§ãªã„ã‚„ã¤å¥½ãã€‚

## solution

é­”æ³•ã‚’ä½¿ã£ãŸå¾Œã®çŠ¶æ…‹ã¯é€£ç«‹æ–¹ç¨‹å¼ã‚’ç«‹ã¦ã¦è¡Œåˆ—ã€‚ä½¿ã†å‰ã®çŠ¶æ…‹ã¯DPã€‚$O(M^3 + N)$ã€‚

æŠ˜ã‚Šè¿”ã—ãŒãªã„éƒ¨åˆ†ã«ã¤ã„ã¦ã€‚
ã•ã„ã“ã‚ã‚’æŒ¯ã‚Œã°$\mathrm{dp}(i) = \frac{1}{m} \sum\_{i+1 \le j \le i+m} (c_j + \mathrm{dp}(j))$ã®å˜ç´”ãªDPã€‚
é­”æ³•ã‚’ä½¿ã†å ´åˆã¯$\mathrm{dp}(i) = \min\_{i+1 \le j \le i+m} (c_j + \mathrm{dp}(j))$ã€‚
ã“ã‚Œã‚‰ã¯é©åˆ‡ã«ã™ã‚Œã°$O(N)$ã«ãªã‚‹ã€‚

æŠ˜ã‚Šè¿”ã—ãŒã‚ã‚‹éƒ¨åˆ†ã«ã¤ã„ã¦ã€‚
ã¾ã é­”æ³•ã‚’ä½¿ã£ã¦ãªã„å ´åˆã¯ä½¿ã£ã¦ã‚´ãƒ¼ãƒ«ã«é£›ã¹ã°ã‚ˆã„ã€‚
ä½¿ã£ã¦ã—ã¾ã£ã¦ã„ã‚‹å ´åˆãŒå•é¡Œã€‚
$\mathrm{dp}(i)$ãŒä¾å­˜ã™ã‚‹ã®ãŒ$j \lt i$ãª$\mathrm{dp}(j)$ã«ãªã‚Šã†ã‚‹ã®ã§ã€æ•´ç¤ã§ãªãDPã§ã¯è¨ˆç®—ã§ããªã„ã€‚
ã—ã‹ã—æ–¹ç¨‹å¼ã¯ç«‹ã£ã¦ã„ã‚‹ã®ã§ã€ã“ã‚Œã‚’æƒãå‡ºã—æ³•ãªã©ã§è§£ã‘ã°æ±‚ã¾ã‚‹ã€‚$O(M^3)$ã€‚

## implementation

``` c++
#include <cstdio>
#include <vector>
#include <cmath>
#include <cassert>
#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))
#define repeat_from(i,m,n) for (int i = (m); (i) < int(n); ++(i))
#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))
typedef long long ll;
using namespace std;
template <class T> void setmin(T & a, T const & b) { if (b < a) a = b; }
template <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }
template <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }

using real = double;
const real eps = 1e-14;

vector<vector<real> > operator * (vector<vector<real> > const & p, vector<vector<real> > const & q) {
    int n = p.size();
    vector<vector<real> > r(n, vector<real>(n));
    repeat (y,n) repeat (z,n) repeat (x,n) r[y][x] += p[y][z] * q[z][x];
    return r;
}
vector<real> operator * (vector<vector<real> > const & p, vector<real> const & q) {
    int n = p.size();
    vector<real> r(n);
    repeat (y,n) repeat (z,n) r[y] += p[y][z] * q[z];
    return r;
}
vector<vector<real> > unit_matrix(int n) {
    vector<vector<real> > e(n, vector<real>(n));
    repeat (i,n) e[i][i] = 1;
    return e;
}
vector<vector<real> > zero_matrix(int n) {
    vector<vector<real> > o(n, vector<real>(n));
    return o;
}

vector<real> gaussian_elimination(vector<vector<real> > f, vector<real> x) {
    int n = x.size();
    repeat (y,n) {
        int pivot = y;
        while (pivot < n and abs(f[pivot][y]) < eps) ++ pivot;
        assert (pivot < n);
        swap(f[y], f[pivot]);
        x[y] /= f[y][y];
        repeat_from (x,y+1,n) f[y][x] /= f[y][y];
        f[y][y] = 1;
        repeat (ny,n) if (ny != y) {
            x[ny] -= f[ny][y] * x[y];
            repeat_from (x,y+1,n) f[ny][x] -= f[ny][y] * f[y][x];
            f[ny][y] = 0;
        }
    }
    return x;
}

int main() {
    int n, m; scanf("%d%d", &n, &m);
    vector<int> c(n); repeat (i,n-2) scanf("%d", &c[i+1]);
    vector<real> init; {
        vector<vector<real> > f = vectors(m-1, m-1, real());
        vector<real> v = vectors(m-1, real());
        repeat (y,m-1) {
            f[y][y] += m;
            repeat (x,m) {
                int z = min(y+x+1, 2*(m-1)-(y+x+1));
                if (z == m-1) continue;
                f[y][z] -= 1;
                v[y] += c[n-m+z];
            }
        }
        init = gaussian_elimination(f, v);
    }
    vector<real> dp1(n);
    repeat_reverse (i,n) {
        if (i == n-1) {
            // zero
        } else if (n-m <= i) {
            dp1[i] = init[i-(n-m)];
        } else {
            repeat (j,m) dp1[i] += (c[i+j+1] + dp1[i+j+1]) / m;
        }
    }
    vector<real> dp0(n);
    repeat_reverse (i,n) {
        if (n-m-1 <= i) {
            // zero
        } else {
            repeat (j,m) dp0[i] += (c[i+j+1] + dp0[i+j+1]) / m;
            repeat (j,m) setmin(dp0[i], c[i+j+1] + dp1[i+j+1]);
        }
    }
    printf("%.12lf\n", dp0[0]);
    return 0;
}
```
