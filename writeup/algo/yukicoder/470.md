---
layout: post
alias: "/blog/2016/12/21/yuki-470/"
date: "2016-12-21T16:53:52+09:00"
title: "Yukicoder No.470 Inverse S+T Problem"
tags: [ "competitive", "writeup", "yukicoder", "2-sat", "strongly-connected-components-decomposition" ]
"target_url": [ "http://yukicoder.me/problems/no/470" ]
---

pirozã•ã‚“ãŒwriterã€‚testerã‚’ã—ã¾ã—ãŸã€‚
å¤œä¸­$3$æ™‚åŠã«ã€ŒğŸ”¥ä½œæˆä¸­ğŸ”¥ã§ã™ãŒã€
ã¨testerå‹Ÿé›†ã—ã¦ã¦ã¤ã‚‰ãã†ã ã£ãŸãŒã€ãã‚Œãªã‚Šã«ä½™è£•æŒã£ã¦å®Œæˆã—ã¦ã„ãŸã€‚

$2$-satã®è©±ã¯(èŸ»æœ¬ã«è¼‰ã£ã¦ã‚‹ã«ã‚‚ã‹ã‹ã‚ã‚‰ãš)å¿˜ã‚Œã¦ã„ãŸã®ã§ã€å§‹ã‚ã¯æœ€å¤§æµä¸­å¿ƒã«è€ƒãˆã¦åŸ‹ã‚ã‚‹ç‡ƒã‚„ã™å•é¡Œã‚ãŸã‚Šã‚’ããã£ãŸã‚Šã—ã¦ã„ãŸã€‚
å§‹ã‚ã‹ã‚‰ãƒ•ãƒ­ãƒ¼ã«æµã‚ŒãŸã“ã¨ã‚‚ã‚ã‚Šæ¢ç´¢è§£ã‚’è»½ãè¦‹ã¦ã—ã¾ã£ã¦ãŠã‚Šã€
å®Ÿè³ªçš„ã«$N \le 52$ãªã®ã§æ°—åˆã„ã§æ¢ç´¢ã§ã‚‚ãªã‚“ã¨ã‹ãªã‚‹ã‹ã‚‚ã ãŒæƒ³å®šè§£ã‚ˆã‚Šæ‰‹é–“ãªã‚“ã ã‹ã‚‰æ°—ã«ã—ãªãã¦ã‚‚ã‚ˆã•ãã†ã€ã¨æ€ã£ã¦ãŸã‚‰æ¢ç´¢ã§ç°¡å˜ã«é€šã•ã‚Œã¦ãŸã€‚
testerã¨ã—ã¦ãªã‚“ã ã‹ç”³ã—è¨³ãªã•ãŒã‚ã‚‹ã€‚

## solution

$2$-satã«è½ã¨ã™ã€‚æ–‡å­—ç¨®$L = 52$ã«å¯¾ã—$O({(\min \\{ L, N \\})}^2)$ã€‚
$2$-satã¯é …æ•°ã®ç·šå½¢ã§è§£ã‘ã‚‹ã“ã¨ãŒçŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã€‚é …æ•°ã¯$O(N^2)$ã§å¢—ãˆã‚‹ãŒã€$N \gt L$ãªã‚‰å¸¸ã«`Impossible`ãªã®ã§å•é¡Œãªã„ã€‚

å„æ–‡å­—åˆ—$U_i$ã«å¯¾ã—ã€$\|S_i\| = 1 \land \|T_i\| = 2$ã¨åˆ†å‰²ã™ã‚‹ã“ã¨ã‚’è¡¨ã‚ã™å‘½é¡Œå¤‰æ•°$x_i$ã‚’ç”¨æ„ã™ã‚‹ã€‚
ã“ã‚Œã‚‰$x_1, x_2, \dots, x_n$ã®é–“ã®åˆ¶ç´„ã‚’è€ƒãˆã‚‹ã¨ã€$S_1, S_2, \dots, S_N, T_1, T_2, \dots, T_N$ã®distinctåˆ¶ç´„ã«ã‚ˆã‚Šä¸¡ç«‹ã§ããªã„ã‚ˆã†ãªliteralã®çµ„ãŒã„ãã¤ã‹ã‚ã‚Šã€ãã‚Œã ã‘ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ä¸¡ç«‹ã§ããªã„ã‚ˆã†ãªliteralã®å¯¾ã‚’åˆ—æŒ™ã—ã¦$(l_1 \lor l_2) \land (l_3 \lor l_4) \land \dots \land (l\_{k-1} \lor l_k)$ã¨ã—ã¦è§£ã‘ã°ã‚ˆã„ã€‚

$2$-satã¯å¼·é€£çµæˆåˆ†åˆ†è§£ã‚’ä½¿ã£ã¦è§£ãã€‚è©³ã—ãã¯èŸ»æœ¬ã‚’ã€‚

## implementation

``` c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <cassert>
#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))
#define repeat_from(i,m,n) for (int i = (m); (i) < int(n); ++(i))
using namespace std;

struct strongly_connected_components {
    static pair<int,vector<int> > decompose(vector<vector<int> > const & g) { // adjacent list
        strongly_connected_components scc(g);
        return { scc.k, scc.c };
    }
private:
    int n;
    vector<vector<int> > to, from;
    explicit strongly_connected_components(vector<vector<int> > const & g) : n(g.size()), to(g), from(n) {
        repeat (i,n) for (int j : to[i]) from[j].push_back(i);
        decompose();
    }
    vector<bool> used;
    vector<int> vs;
    void dfs(int i) {
        used[i] = true;
        for (int j : to[i]) if (not used[j]) dfs(j);
        vs.push_back(i);
    }
    int k; // number of scc
    vector<int> c; // i-th vertex in g is in c_i-th vertex in scc-decomposed g
    void rdfs(int i) {
        used[i] = true;
        c[i] = k;
        for (int j : from[i]) if (not used[j]) rdfs(j);
    }
    void decompose() {
        used.clear(); used.resize(n, false);
        repeat (i,n) if (not used[i]) dfs(i);
        used.clear(); used.resize(n, false);
        k = 0;
        c.resize(n);
        reverse(vs.begin(), vs.end());
        for (int i : vs) if (not used[i]) {
            rdfs(i);
            k += 1;
        }
    }
};

vector<bool> twosat(int n, vector<pair<int, int> > const & cnf) {
    vector<vector<int> > g(2*n);
    auto i = [&](int x) { assert (x != 0 and abs(x) <= n); return x > 0 ? x-1 : n-x-1; };
    for (auto it : cnf) {
        int x, y; tie(x, y) = it; // x or y
        g[i(- x)].push_back(i(y)); // not x implies y
        g[i(- y)].push_back(i(x)); // not y implies x
    }
    vector<int> component = strongly_connected_components::decompose(g).second;
    vector<bool> valuation(n);
    repeat_from (x,1,n+1) {
        if (component[i(x)] == component[i(- x)]) { // x iff not x
            return vector<bool>(); // unsat
        }
        valuation[x-1] = component[i(x)] > component[i(- x)]; // use components which indices are large
    }
    return valuation;
}

int main() {
    int n; cin >> n;
    vector<string> s(n); repeat (i,n) cin >> s[i];
    assert (1 <= n and n <= 100000);
    repeat (i,n) {
        assert (s[i].length() == 3);
        for (char c : s[i]) assert ('A' <= c and c <= 'Z' or 'a' <= c and c <= 'z');
    }
    vector<bool> result;
    if (n <= 52) {
        //     x_i : U_i = S + TT
        // not x_i : U_i = SS + T
        vector<pair<int, int> > cnf;
        map<string, vector<int> > used;
        repeat (i,n) {
            int x = i + 1;
            used[s[i].substr(0, 1)].push_back(+ x);
            used[s[i].substr(1, 2)].push_back(+ x);
            used[s[i].substr(0, 2)].push_back(- x);
            used[s[i].substr(2, 1)].push_back(- x);
        }
        for (auto it : used) {
            for (int x : it.second) for (int y : it.second) if (x < y) {
                // cerr << "not " << x << " or " << "not " << y << endl;
                cnf.emplace_back(- x, - y); // not x or not y
            }
        }
        result = twosat(n, cnf);
    }
    if (result.empty()) {
        cout << "Impossible" << endl;
    } else {
        repeat (i,n) {
            if (result[i]) {
                cout << s[i][0] << ' ' << s[i][1] << s[i][2] << endl;
            } else {
                cout << s[i][0] << s[i][1] << ' ' << s[i][2] << endl;
            }
        }
    }
    return 0;
}
```
